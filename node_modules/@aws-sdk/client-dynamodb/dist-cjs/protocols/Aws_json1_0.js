"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.se_UpdateItemCommand = exports.se_UpdateGlobalTableSettingsCommand = exports.se_UpdateGlobalTableCommand = exports.se_UpdateContributorInsightsCommand = exports.se_UpdateContinuousBackupsCommand = exports.se_UntagResourceCommand = exports.se_TransactWriteItemsCommand = exports.se_TransactGetItemsCommand = exports.se_TagResourceCommand = exports.se_ScanCommand = exports.se_RestoreTableToPointInTimeCommand = exports.se_RestoreTableFromBackupCommand = exports.se_QueryCommand = exports.se_PutItemCommand = exports.se_ListTagsOfResourceCommand = exports.se_ListTablesCommand = exports.se_ListImportsCommand = exports.se_ListGlobalTablesCommand = exports.se_ListExportsCommand = exports.se_ListContributorInsightsCommand = exports.se_ListBackupsCommand = exports.se_ImportTableCommand = exports.se_GetItemCommand = exports.se_ExportTableToPointInTimeCommand = exports.se_ExecuteTransactionCommand = exports.se_ExecuteStatementCommand = exports.se_EnableKinesisStreamingDestinationCommand = exports.se_DisableKinesisStreamingDestinationCommand = exports.se_DescribeTimeToLiveCommand = exports.se_DescribeTableReplicaAutoScalingCommand = exports.se_DescribeTableCommand = exports.se_DescribeLimitsCommand = exports.se_DescribeKinesisStreamingDestinationCommand = exports.se_DescribeImportCommand = exports.se_DescribeGlobalTableSettingsCommand = exports.se_DescribeGlobalTableCommand = exports.se_DescribeExportCommand = exports.se_DescribeEndpointsCommand = exports.se_DescribeContributorInsightsCommand = exports.se_DescribeContinuousBackupsCommand = exports.se_DescribeBackupCommand = exports.se_DeleteTableCommand = exports.se_DeleteItemCommand = exports.se_DeleteBackupCommand = exports.se_CreateTableCommand = exports.se_CreateGlobalTableCommand = exports.se_CreateBackupCommand = exports.se_BatchWriteItemCommand = exports.se_BatchGetItemCommand = exports.se_BatchExecuteStatementCommand = void 0;
exports.de_UpdateContributorInsightsCommand = exports.de_UpdateContinuousBackupsCommand = exports.de_UntagResourceCommand = exports.de_TransactWriteItemsCommand = exports.de_TransactGetItemsCommand = exports.de_TagResourceCommand = exports.de_ScanCommand = exports.de_RestoreTableToPointInTimeCommand = exports.de_RestoreTableFromBackupCommand = exports.de_QueryCommand = exports.de_PutItemCommand = exports.de_ListTagsOfResourceCommand = exports.de_ListTablesCommand = exports.de_ListImportsCommand = exports.de_ListGlobalTablesCommand = exports.de_ListExportsCommand = exports.de_ListContributorInsightsCommand = exports.de_ListBackupsCommand = exports.de_ImportTableCommand = exports.de_GetItemCommand = exports.de_ExportTableToPointInTimeCommand = exports.de_ExecuteTransactionCommand = exports.de_ExecuteStatementCommand = exports.de_EnableKinesisStreamingDestinationCommand = exports.de_DisableKinesisStreamingDestinationCommand = exports.de_DescribeTimeToLiveCommand = exports.de_DescribeTableReplicaAutoScalingCommand = exports.de_DescribeTableCommand = exports.de_DescribeLimitsCommand = exports.de_DescribeKinesisStreamingDestinationCommand = exports.de_DescribeImportCommand = exports.de_DescribeGlobalTableSettingsCommand = exports.de_DescribeGlobalTableCommand = exports.de_DescribeExportCommand = exports.de_DescribeEndpointsCommand = exports.de_DescribeContributorInsightsCommand = exports.de_DescribeContinuousBackupsCommand = exports.de_DescribeBackupCommand = exports.de_DeleteTableCommand = exports.de_DeleteItemCommand = exports.de_DeleteBackupCommand = exports.de_CreateTableCommand = exports.de_CreateGlobalTableCommand = exports.de_CreateBackupCommand = exports.de_BatchWriteItemCommand = exports.de_BatchGetItemCommand = exports.de_BatchExecuteStatementCommand = exports.se_UpdateTimeToLiveCommand = exports.se_UpdateTableReplicaAutoScalingCommand = exports.se_UpdateTableCommand = void 0;
exports.de_UpdateTimeToLiveCommand = exports.de_UpdateTableReplicaAutoScalingCommand = exports.de_UpdateTableCommand = exports.de_UpdateItemCommand = exports.de_UpdateGlobalTableSettingsCommand = exports.de_UpdateGlobalTableCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const uuid_1 = require("uuid");
const DynamoDBServiceException_1 = require("../models/DynamoDBServiceException");
const models_0_1 = require("../models/models_0");
const se_BatchExecuteStatementCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.BatchExecuteStatement",
    };
    let body;
    body = JSON.stringify(se_BatchExecuteStatementInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchExecuteStatementCommand = se_BatchExecuteStatementCommand;
const se_BatchGetItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.BatchGetItem",
    };
    let body;
    body = JSON.stringify(se_BatchGetItemInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetItemCommand = se_BatchGetItemCommand;
const se_BatchWriteItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.BatchWriteItem",
    };
    let body;
    body = JSON.stringify(se_BatchWriteItemInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchWriteItemCommand = se_BatchWriteItemCommand;
const se_CreateBackupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.CreateBackup",
    };
    let body;
    body = JSON.stringify(se_CreateBackupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateBackupCommand = se_CreateBackupCommand;
const se_CreateGlobalTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.CreateGlobalTable",
    };
    let body;
    body = JSON.stringify(se_CreateGlobalTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateGlobalTableCommand = se_CreateGlobalTableCommand;
const se_CreateTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.CreateTable",
    };
    let body;
    body = JSON.stringify(se_CreateTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateTableCommand = se_CreateTableCommand;
const se_DeleteBackupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DeleteBackup",
    };
    let body;
    body = JSON.stringify(se_DeleteBackupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteBackupCommand = se_DeleteBackupCommand;
const se_DeleteItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DeleteItem",
    };
    let body;
    body = JSON.stringify(se_DeleteItemInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteItemCommand = se_DeleteItemCommand;
const se_DeleteTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DeleteTable",
    };
    let body;
    body = JSON.stringify(se_DeleteTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteTableCommand = se_DeleteTableCommand;
const se_DescribeBackupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeBackup",
    };
    let body;
    body = JSON.stringify(se_DescribeBackupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeBackupCommand = se_DescribeBackupCommand;
const se_DescribeContinuousBackupsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeContinuousBackups",
    };
    let body;
    body = JSON.stringify(se_DescribeContinuousBackupsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeContinuousBackupsCommand = se_DescribeContinuousBackupsCommand;
const se_DescribeContributorInsightsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeContributorInsights",
    };
    let body;
    body = JSON.stringify(se_DescribeContributorInsightsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeContributorInsightsCommand = se_DescribeContributorInsightsCommand;
const se_DescribeEndpointsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeEndpoints",
    };
    let body;
    body = JSON.stringify(se_DescribeEndpointsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeEndpointsCommand = se_DescribeEndpointsCommand;
const se_DescribeExportCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeExport",
    };
    let body;
    body = JSON.stringify(se_DescribeExportInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeExportCommand = se_DescribeExportCommand;
const se_DescribeGlobalTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeGlobalTable",
    };
    let body;
    body = JSON.stringify(se_DescribeGlobalTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeGlobalTableCommand = se_DescribeGlobalTableCommand;
const se_DescribeGlobalTableSettingsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeGlobalTableSettings",
    };
    let body;
    body = JSON.stringify(se_DescribeGlobalTableSettingsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeGlobalTableSettingsCommand = se_DescribeGlobalTableSettingsCommand;
const se_DescribeImportCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeImport",
    };
    let body;
    body = JSON.stringify(se_DescribeImportInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeImportCommand = se_DescribeImportCommand;
const se_DescribeKinesisStreamingDestinationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeKinesisStreamingDestination",
    };
    let body;
    body = JSON.stringify(se_DescribeKinesisStreamingDestinationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeKinesisStreamingDestinationCommand = se_DescribeKinesisStreamingDestinationCommand;
const se_DescribeLimitsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeLimits",
    };
    let body;
    body = JSON.stringify(se_DescribeLimitsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeLimitsCommand = se_DescribeLimitsCommand;
const se_DescribeTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeTable",
    };
    let body;
    body = JSON.stringify(se_DescribeTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeTableCommand = se_DescribeTableCommand;
const se_DescribeTableReplicaAutoScalingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeTableReplicaAutoScaling",
    };
    let body;
    body = JSON.stringify(se_DescribeTableReplicaAutoScalingInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeTableReplicaAutoScalingCommand = se_DescribeTableReplicaAutoScalingCommand;
const se_DescribeTimeToLiveCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DescribeTimeToLive",
    };
    let body;
    body = JSON.stringify(se_DescribeTimeToLiveInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeTimeToLiveCommand = se_DescribeTimeToLiveCommand;
const se_DisableKinesisStreamingDestinationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.DisableKinesisStreamingDestination",
    };
    let body;
    body = JSON.stringify(se_KinesisStreamingDestinationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DisableKinesisStreamingDestinationCommand = se_DisableKinesisStreamingDestinationCommand;
const se_EnableKinesisStreamingDestinationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.EnableKinesisStreamingDestination",
    };
    let body;
    body = JSON.stringify(se_KinesisStreamingDestinationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_EnableKinesisStreamingDestinationCommand = se_EnableKinesisStreamingDestinationCommand;
const se_ExecuteStatementCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ExecuteStatement",
    };
    let body;
    body = JSON.stringify(se_ExecuteStatementInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ExecuteStatementCommand = se_ExecuteStatementCommand;
const se_ExecuteTransactionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ExecuteTransaction",
    };
    let body;
    body = JSON.stringify(se_ExecuteTransactionInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ExecuteTransactionCommand = se_ExecuteTransactionCommand;
const se_ExportTableToPointInTimeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ExportTableToPointInTime",
    };
    let body;
    body = JSON.stringify(se_ExportTableToPointInTimeInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ExportTableToPointInTimeCommand = se_ExportTableToPointInTimeCommand;
const se_GetItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.GetItem",
    };
    let body;
    body = JSON.stringify(se_GetItemInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetItemCommand = se_GetItemCommand;
const se_ImportTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ImportTable",
    };
    let body;
    body = JSON.stringify(se_ImportTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ImportTableCommand = se_ImportTableCommand;
const se_ListBackupsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ListBackups",
    };
    let body;
    body = JSON.stringify(se_ListBackupsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListBackupsCommand = se_ListBackupsCommand;
const se_ListContributorInsightsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ListContributorInsights",
    };
    let body;
    body = JSON.stringify(se_ListContributorInsightsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListContributorInsightsCommand = se_ListContributorInsightsCommand;
const se_ListExportsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ListExports",
    };
    let body;
    body = JSON.stringify(se_ListExportsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListExportsCommand = se_ListExportsCommand;
const se_ListGlobalTablesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ListGlobalTables",
    };
    let body;
    body = JSON.stringify(se_ListGlobalTablesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListGlobalTablesCommand = se_ListGlobalTablesCommand;
const se_ListImportsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ListImports",
    };
    let body;
    body = JSON.stringify(se_ListImportsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListImportsCommand = se_ListImportsCommand;
const se_ListTablesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ListTables",
    };
    let body;
    body = JSON.stringify(se_ListTablesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListTablesCommand = se_ListTablesCommand;
const se_ListTagsOfResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.ListTagsOfResource",
    };
    let body;
    body = JSON.stringify(se_ListTagsOfResourceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListTagsOfResourceCommand = se_ListTagsOfResourceCommand;
const se_PutItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.PutItem",
    };
    let body;
    body = JSON.stringify(se_PutItemInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutItemCommand = se_PutItemCommand;
const se_QueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.Query",
    };
    let body;
    body = JSON.stringify(se_QueryInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_QueryCommand = se_QueryCommand;
const se_RestoreTableFromBackupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.RestoreTableFromBackup",
    };
    let body;
    body = JSON.stringify(se_RestoreTableFromBackupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RestoreTableFromBackupCommand = se_RestoreTableFromBackupCommand;
const se_RestoreTableToPointInTimeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.RestoreTableToPointInTime",
    };
    let body;
    body = JSON.stringify(se_RestoreTableToPointInTimeInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RestoreTableToPointInTimeCommand = se_RestoreTableToPointInTimeCommand;
const se_ScanCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.Scan",
    };
    let body;
    body = JSON.stringify(se_ScanInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ScanCommand = se_ScanCommand;
const se_TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.TagResource",
    };
    let body;
    body = JSON.stringify(se_TagResourceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_TransactGetItemsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.TransactGetItems",
    };
    let body;
    body = JSON.stringify(se_TransactGetItemsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TransactGetItemsCommand = se_TransactGetItemsCommand;
const se_TransactWriteItemsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.TransactWriteItems",
    };
    let body;
    body = JSON.stringify(se_TransactWriteItemsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TransactWriteItemsCommand = se_TransactWriteItemsCommand;
const se_UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UntagResource",
    };
    let body;
    body = JSON.stringify(se_UntagResourceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateContinuousBackupsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateContinuousBackups",
    };
    let body;
    body = JSON.stringify(se_UpdateContinuousBackupsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateContinuousBackupsCommand = se_UpdateContinuousBackupsCommand;
const se_UpdateContributorInsightsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateContributorInsights",
    };
    let body;
    body = JSON.stringify(se_UpdateContributorInsightsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateContributorInsightsCommand = se_UpdateContributorInsightsCommand;
const se_UpdateGlobalTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateGlobalTable",
    };
    let body;
    body = JSON.stringify(se_UpdateGlobalTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateGlobalTableCommand = se_UpdateGlobalTableCommand;
const se_UpdateGlobalTableSettingsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateGlobalTableSettings",
    };
    let body;
    body = JSON.stringify(se_UpdateGlobalTableSettingsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateGlobalTableSettingsCommand = se_UpdateGlobalTableSettingsCommand;
const se_UpdateItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateItem",
    };
    let body;
    body = JSON.stringify(se_UpdateItemInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateItemCommand = se_UpdateItemCommand;
const se_UpdateTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateTable",
    };
    let body;
    body = JSON.stringify(se_UpdateTableInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateTableCommand = se_UpdateTableCommand;
const se_UpdateTableReplicaAutoScalingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateTableReplicaAutoScaling",
    };
    let body;
    body = JSON.stringify(se_UpdateTableReplicaAutoScalingInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateTableReplicaAutoScalingCommand = se_UpdateTableReplicaAutoScalingCommand;
const se_UpdateTimeToLiveCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "DynamoDB_20120810.UpdateTimeToLive",
    };
    let body;
    body = JSON.stringify(se_UpdateTimeToLiveInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateTimeToLiveCommand = se_UpdateTimeToLiveCommand;
const de_BatchExecuteStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchExecuteStatementCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchExecuteStatementOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_BatchExecuteStatementCommand = de_BatchExecuteStatementCommand;
const de_BatchExecuteStatementCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_BatchGetItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetItemOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_BatchGetItemCommand = de_BatchGetItemCommand;
const de_BatchGetItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_BatchWriteItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchWriteItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchWriteItemOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_BatchWriteItemCommand = de_BatchWriteItemCommand;
const de_BatchWriteItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ItemCollectionSizeLimitExceededException":
        case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
            throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_CreateBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateBackupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateBackupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_CreateBackupCommand = de_CreateBackupCommand;
const de_CreateBackupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BackupInUseException":
        case "com.amazonaws.dynamodb#BackupInUseException":
            throw await de_BackupInUseExceptionRes(parsedOutput, context);
        case "ContinuousBackupsUnavailableException":
        case "com.amazonaws.dynamodb#ContinuousBackupsUnavailableException":
            throw await de_ContinuousBackupsUnavailableExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TableInUseException":
        case "com.amazonaws.dynamodb#TableInUseException":
            throw await de_TableInUseExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_CreateGlobalTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateGlobalTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGlobalTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_CreateGlobalTableCommand = de_CreateGlobalTableCommand;
const de_CreateGlobalTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GlobalTableAlreadyExistsException":
        case "com.amazonaws.dynamodb#GlobalTableAlreadyExistsException":
            throw await de_GlobalTableAlreadyExistsExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_CreateTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_CreateTableCommand = de_CreateTableCommand;
const de_CreateTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DeleteBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteBackupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteBackupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DeleteBackupCommand = de_DeleteBackupCommand;
const de_DeleteBackupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BackupInUseException":
        case "com.amazonaws.dynamodb#BackupInUseException":
            throw await de_BackupInUseExceptionRes(parsedOutput, context);
        case "BackupNotFoundException":
        case "com.amazonaws.dynamodb#BackupNotFoundException":
            throw await de_BackupNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DeleteItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteItemOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DeleteItemCommand = de_DeleteItemCommand;
const de_DeleteItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConditionalCheckFailedException":
        case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
            throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ItemCollectionSizeLimitExceededException":
        case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
            throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TransactionConflictException":
        case "com.amazonaws.dynamodb#TransactionConflictException":
            throw await de_TransactionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DeleteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DeleteTableCommand = de_DeleteTableCommand;
const de_DeleteTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeBackupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeBackupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeBackupCommand = de_DescribeBackupCommand;
const de_DescribeBackupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BackupNotFoundException":
        case "com.amazonaws.dynamodb#BackupNotFoundException":
            throw await de_BackupNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeContinuousBackupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeContinuousBackupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeContinuousBackupsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeContinuousBackupsCommand = de_DescribeContinuousBackupsCommand;
const de_DescribeContinuousBackupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeContributorInsightsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeContributorInsightsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeContributorInsightsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeContributorInsightsCommand = de_DescribeContributorInsightsCommand;
const de_DescribeContributorInsightsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEndpointsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeEndpointsCommand = de_DescribeEndpointsCommand;
const de_DescribeEndpointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    (0, smithy_client_1.throwDefaultError)({
        output,
        parsedBody,
        exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
        errorCode,
    });
};
const de_DescribeExportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeExportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeExportOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeExportCommand = de_DescribeExportCommand;
const de_DescribeExportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExportNotFoundException":
        case "com.amazonaws.dynamodb#ExportNotFoundException":
            throw await de_ExportNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeGlobalTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeGlobalTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeGlobalTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeGlobalTableCommand = de_DescribeGlobalTableCommand;
const de_DescribeGlobalTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GlobalTableNotFoundException":
        case "com.amazonaws.dynamodb#GlobalTableNotFoundException":
            throw await de_GlobalTableNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeGlobalTableSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeGlobalTableSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeGlobalTableSettingsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeGlobalTableSettingsCommand = de_DescribeGlobalTableSettingsCommand;
const de_DescribeGlobalTableSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GlobalTableNotFoundException":
        case "com.amazonaws.dynamodb#GlobalTableNotFoundException":
            throw await de_GlobalTableNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeImportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeImportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeImportOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeImportCommand = de_DescribeImportCommand;
const de_DescribeImportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ImportNotFoundException":
        case "com.amazonaws.dynamodb#ImportNotFoundException":
            throw await de_ImportNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeKinesisStreamingDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeKinesisStreamingDestinationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeKinesisStreamingDestinationOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeKinesisStreamingDestinationCommand = de_DescribeKinesisStreamingDestinationCommand;
const de_DescribeKinesisStreamingDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLimitsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLimitsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeLimitsCommand = de_DescribeLimitsCommand;
const de_DescribeLimitsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeTableCommand = de_DescribeTableCommand;
const de_DescribeTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeTableReplicaAutoScalingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTableReplicaAutoScalingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTableReplicaAutoScalingOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeTableReplicaAutoScalingCommand = de_DescribeTableReplicaAutoScalingCommand;
const de_DescribeTableReplicaAutoScalingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DescribeTimeToLiveCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTimeToLiveCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTimeToLiveOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DescribeTimeToLiveCommand = de_DescribeTimeToLiveCommand;
const de_DescribeTimeToLiveCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_DisableKinesisStreamingDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableKinesisStreamingDestinationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_KinesisStreamingDestinationOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_DisableKinesisStreamingDestinationCommand = de_DisableKinesisStreamingDestinationCommand;
const de_DisableKinesisStreamingDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_EnableKinesisStreamingDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableKinesisStreamingDestinationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_KinesisStreamingDestinationOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_EnableKinesisStreamingDestinationCommand = de_EnableKinesisStreamingDestinationCommand;
const de_EnableKinesisStreamingDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ExecuteStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ExecuteStatementCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExecuteStatementOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ExecuteStatementCommand = de_ExecuteStatementCommand;
const de_ExecuteStatementCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConditionalCheckFailedException":
        case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
            throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
        case "DuplicateItemException":
        case "com.amazonaws.dynamodb#DuplicateItemException":
            throw await de_DuplicateItemExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ItemCollectionSizeLimitExceededException":
        case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
            throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TransactionConflictException":
        case "com.amazonaws.dynamodb#TransactionConflictException":
            throw await de_TransactionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ExecuteTransactionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ExecuteTransactionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExecuteTransactionOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ExecuteTransactionCommand = de_ExecuteTransactionCommand;
const de_ExecuteTransactionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.dynamodb#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TransactionCanceledException":
        case "com.amazonaws.dynamodb#TransactionCanceledException":
            throw await de_TransactionCanceledExceptionRes(parsedOutput, context);
        case "TransactionInProgressException":
        case "com.amazonaws.dynamodb#TransactionInProgressException":
            throw await de_TransactionInProgressExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ExportTableToPointInTimeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ExportTableToPointInTimeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportTableToPointInTimeOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ExportTableToPointInTimeCommand = de_ExportTableToPointInTimeCommand;
const de_ExportTableToPointInTimeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExportConflictException":
        case "com.amazonaws.dynamodb#ExportConflictException":
            throw await de_ExportConflictExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidExportTimeException":
        case "com.amazonaws.dynamodb#InvalidExportTimeException":
            throw await de_InvalidExportTimeExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "PointInTimeRecoveryUnavailableException":
        case "com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException":
            throw await de_PointInTimeRecoveryUnavailableExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_GetItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetItemOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_GetItemCommand = de_GetItemCommand;
const de_GetItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ImportTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ImportTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ImportTableCommand = de_ImportTableCommand;
const de_ImportTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ImportConflictException":
        case "com.amazonaws.dynamodb#ImportConflictException":
            throw await de_ImportConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ListBackupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListBackupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListBackupsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ListBackupsCommand = de_ListBackupsCommand;
const de_ListBackupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ListContributorInsightsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListContributorInsightsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListContributorInsightsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ListContributorInsightsCommand = de_ListContributorInsightsCommand;
const de_ListContributorInsightsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ListExportsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListExportsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListExportsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ListExportsCommand = de_ListExportsCommand;
const de_ListExportsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ListGlobalTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGlobalTablesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGlobalTablesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ListGlobalTablesCommand = de_ListGlobalTablesCommand;
const de_ListGlobalTablesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ListImportsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListImportsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListImportsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ListImportsCommand = de_ListImportsCommand;
const de_ListImportsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ListTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTablesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListTablesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ListTablesCommand = de_ListTablesCommand;
const de_ListTablesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ListTagsOfResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsOfResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListTagsOfResourceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ListTagsOfResourceCommand = de_ListTagsOfResourceCommand;
const de_ListTagsOfResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_PutItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutItemOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_PutItemCommand = de_PutItemCommand;
const de_PutItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConditionalCheckFailedException":
        case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
            throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ItemCollectionSizeLimitExceededException":
        case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
            throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TransactionConflictException":
        case "com.amazonaws.dynamodb#TransactionConflictException":
            throw await de_TransactionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_QueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_QueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_QueryOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_QueryCommand = de_QueryCommand;
const de_QueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_RestoreTableFromBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RestoreTableFromBackupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreTableFromBackupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_RestoreTableFromBackupCommand = de_RestoreTableFromBackupCommand;
const de_RestoreTableFromBackupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BackupInUseException":
        case "com.amazonaws.dynamodb#BackupInUseException":
            throw await de_BackupInUseExceptionRes(parsedOutput, context);
        case "BackupNotFoundException":
        case "com.amazonaws.dynamodb#BackupNotFoundException":
            throw await de_BackupNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TableAlreadyExistsException":
        case "com.amazonaws.dynamodb#TableAlreadyExistsException":
            throw await de_TableAlreadyExistsExceptionRes(parsedOutput, context);
        case "TableInUseException":
        case "com.amazonaws.dynamodb#TableInUseException":
            throw await de_TableInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_RestoreTableToPointInTimeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RestoreTableToPointInTimeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreTableToPointInTimeOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_RestoreTableToPointInTimeCommand = de_RestoreTableToPointInTimeCommand;
const de_RestoreTableToPointInTimeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "InvalidRestoreTimeException":
        case "com.amazonaws.dynamodb#InvalidRestoreTimeException":
            throw await de_InvalidRestoreTimeExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "PointInTimeRecoveryUnavailableException":
        case "com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException":
            throw await de_PointInTimeRecoveryUnavailableExceptionRes(parsedOutput, context);
        case "TableAlreadyExistsException":
        case "com.amazonaws.dynamodb#TableAlreadyExistsException":
            throw await de_TableAlreadyExistsExceptionRes(parsedOutput, context);
        case "TableInUseException":
        case "com.amazonaws.dynamodb#TableInUseException":
            throw await de_TableInUseExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_ScanCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ScanCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ScanOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_ScanCommand = de_ScanCommand;
const de_ScanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_TransactGetItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TransactGetItemsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TransactGetItemsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_TransactGetItemsCommand = de_TransactGetItemsCommand;
const de_TransactGetItemsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TransactionCanceledException":
        case "com.amazonaws.dynamodb#TransactionCanceledException":
            throw await de_TransactionCanceledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_TransactWriteItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TransactWriteItemsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TransactWriteItemsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_TransactWriteItemsCommand = de_TransactWriteItemsCommand;
const de_TransactWriteItemsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.dynamodb#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TransactionCanceledException":
        case "com.amazonaws.dynamodb#TransactionCanceledException":
            throw await de_TransactionCanceledExceptionRes(parsedOutput, context);
        case "TransactionInProgressException":
        case "com.amazonaws.dynamodb#TransactionInProgressException":
            throw await de_TransactionInProgressExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateContinuousBackupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateContinuousBackupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateContinuousBackupsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateContinuousBackupsCommand = de_UpdateContinuousBackupsCommand;
const de_UpdateContinuousBackupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ContinuousBackupsUnavailableException":
        case "com.amazonaws.dynamodb#ContinuousBackupsUnavailableException":
            throw await de_ContinuousBackupsUnavailableExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateContributorInsightsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateContributorInsightsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateContributorInsightsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateContributorInsightsCommand = de_UpdateContributorInsightsCommand;
const de_UpdateContributorInsightsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateGlobalTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateGlobalTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateGlobalTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateGlobalTableCommand = de_UpdateGlobalTableCommand;
const de_UpdateGlobalTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GlobalTableNotFoundException":
        case "com.amazonaws.dynamodb#GlobalTableNotFoundException":
            throw await de_GlobalTableNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ReplicaAlreadyExistsException":
        case "com.amazonaws.dynamodb#ReplicaAlreadyExistsException":
            throw await de_ReplicaAlreadyExistsExceptionRes(parsedOutput, context);
        case "ReplicaNotFoundException":
        case "com.amazonaws.dynamodb#ReplicaNotFoundException":
            throw await de_ReplicaNotFoundExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateGlobalTableSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateGlobalTableSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateGlobalTableSettingsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateGlobalTableSettingsCommand = de_UpdateGlobalTableSettingsCommand;
const de_UpdateGlobalTableSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GlobalTableNotFoundException":
        case "com.amazonaws.dynamodb#GlobalTableNotFoundException":
            throw await de_GlobalTableNotFoundExceptionRes(parsedOutput, context);
        case "IndexNotFoundException":
        case "com.amazonaws.dynamodb#IndexNotFoundException":
            throw await de_IndexNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ReplicaNotFoundException":
        case "com.amazonaws.dynamodb#ReplicaNotFoundException":
            throw await de_ReplicaNotFoundExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateItemOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateItemCommand = de_UpdateItemCommand;
const de_UpdateItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConditionalCheckFailedException":
        case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
            throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ItemCollectionSizeLimitExceededException":
        case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
            throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TransactionConflictException":
        case "com.amazonaws.dynamodb#TransactionConflictException":
            throw await de_TransactionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateTableOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateTableCommand = de_UpdateTableCommand;
const de_UpdateTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateTableReplicaAutoScalingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateTableReplicaAutoScalingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateTableReplicaAutoScalingOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateTableReplicaAutoScalingCommand = de_UpdateTableReplicaAutoScalingCommand;
const de_UpdateTableReplicaAutoScalingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_UpdateTimeToLiveCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateTimeToLiveCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateTimeToLiveOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.de_UpdateTimeToLiveCommand = de_UpdateTimeToLiveCommand;
const de_UpdateTimeToLiveCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: DynamoDBServiceException_1.DynamoDBServiceException,
                errorCode,
            });
    }
};
const de_BackupInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_BackupInUseException(body, context);
    const exception = new models_0_1.BackupInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BackupNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_BackupNotFoundException(body, context);
    const exception = new models_0_1.BackupNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ConditionalCheckFailedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConditionalCheckFailedException(body, context);
    const exception = new models_0_1.ConditionalCheckFailedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ContinuousBackupsUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ContinuousBackupsUnavailableException(body, context);
    const exception = new models_0_1.ContinuousBackupsUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateItemExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateItemException(body, context);
    const exception = new models_0_1.DuplicateItemException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ExportConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExportConflictException(body, context);
    const exception = new models_0_1.ExportConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ExportNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExportNotFoundException(body, context);
    const exception = new models_0_1.ExportNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_GlobalTableAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_GlobalTableAlreadyExistsException(body, context);
    const exception = new models_0_1.GlobalTableAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_GlobalTableNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_GlobalTableNotFoundException(body, context);
    const exception = new models_0_1.GlobalTableNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IdempotentParameterMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IdempotentParameterMismatchException(body, context);
    const exception = new models_0_1.IdempotentParameterMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ImportConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ImportConflictException(body, context);
    const exception = new models_0_1.ImportConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ImportNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ImportNotFoundException(body, context);
    const exception = new models_0_1.ImportNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IndexNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IndexNotFoundException(body, context);
    const exception = new models_0_1.IndexNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InternalServerErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InternalServerError(body, context);
    const exception = new models_0_1.InternalServerError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidEndpointExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidEndpointException(body, context);
    const exception = new models_0_1.InvalidEndpointException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidExportTimeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidExportTimeException(body, context);
    const exception = new models_0_1.InvalidExportTimeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRestoreTimeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidRestoreTimeException(body, context);
    const exception = new models_0_1.InvalidRestoreTimeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ItemCollectionSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ItemCollectionSizeLimitExceededException(body, context);
    const exception = new models_0_1.ItemCollectionSizeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body, context);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PointInTimeRecoveryUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PointInTimeRecoveryUnavailableException(body, context);
    const exception = new models_0_1.PointInTimeRecoveryUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ProvisionedThroughputExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ProvisionedThroughputExceededException(body, context);
    const exception = new models_0_1.ProvisionedThroughputExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReplicaAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReplicaAlreadyExistsException(body, context);
    const exception = new models_0_1.ReplicaAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReplicaNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReplicaNotFoundException(body, context);
    const exception = new models_0_1.ReplicaNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RequestLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RequestLimitExceeded(body, context);
    const exception = new models_0_1.RequestLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceInUseException(body, context);
    const exception = new models_0_1.ResourceInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundException(body, context);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TableAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TableAlreadyExistsException(body, context);
    const exception = new models_0_1.TableAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TableInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TableInUseException(body, context);
    const exception = new models_0_1.TableInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TableNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TableNotFoundException(body, context);
    const exception = new models_0_1.TableNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TransactionCanceledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TransactionCanceledException(body, context);
    const exception = new models_0_1.TransactionCanceledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TransactionConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TransactionConflictException(body, context);
    const exception = new models_0_1.TransactionConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TransactionInProgressExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TransactionInProgressException(body, context);
    const exception = new models_0_1.TransactionInProgressException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_AttributeDefinition = (input, context) => {
    return {
        ...(input.AttributeName != null && { AttributeName: input.AttributeName }),
        ...(input.AttributeType != null && { AttributeType: input.AttributeType }),
    };
};
const se_AttributeDefinitions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeDefinition(entry, context);
    });
};
const se_AttributeNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_AttributeUpdates = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValueUpdate(value, context);
        return acc;
    }, {});
};
const se_AttributeValue = (input, context) => {
    return models_0_1.AttributeValue.visit(input, {
        B: (value) => ({ B: context.base64Encoder(value) }),
        BOOL: (value) => ({ BOOL: value }),
        BS: (value) => ({ BS: se_BinarySetAttributeValue(value, context) }),
        L: (value) => ({ L: se_ListAttributeValue(value, context) }),
        M: (value) => ({ M: se_MapAttributeValue(value, context) }),
        N: (value) => ({ N: value }),
        NS: (value) => ({ NS: se_NumberSetAttributeValue(value, context) }),
        NULL: (value) => ({ NULL: value }),
        S: (value) => ({ S: value }),
        SS: (value) => ({ SS: se_StringSetAttributeValue(value, context) }),
        _: (name, value) => ({ name: value }),
    });
};
const se_AttributeValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeValue(entry, context);
    });
};
const se_AttributeValueUpdate = (input, context) => {
    return {
        ...(input.Action != null && { Action: input.Action }),
        ...(input.Value != null && { Value: se_AttributeValue(input.Value, context) }),
    };
};
const se_AutoScalingPolicyUpdate = (input, context) => {
    return {
        ...(input.PolicyName != null && { PolicyName: input.PolicyName }),
        ...(input.TargetTrackingScalingPolicyConfiguration != null && {
            TargetTrackingScalingPolicyConfiguration: se_AutoScalingTargetTrackingScalingPolicyConfigurationUpdate(input.TargetTrackingScalingPolicyConfiguration, context),
        }),
    };
};
const se_AutoScalingSettingsUpdate = (input, context) => {
    return {
        ...(input.AutoScalingDisabled != null && { AutoScalingDisabled: input.AutoScalingDisabled }),
        ...(input.AutoScalingRoleArn != null && { AutoScalingRoleArn: input.AutoScalingRoleArn }),
        ...(input.MaximumUnits != null && { MaximumUnits: input.MaximumUnits }),
        ...(input.MinimumUnits != null && { MinimumUnits: input.MinimumUnits }),
        ...(input.ScalingPolicyUpdate != null && {
            ScalingPolicyUpdate: se_AutoScalingPolicyUpdate(input.ScalingPolicyUpdate, context),
        }),
    };
};
const se_AutoScalingTargetTrackingScalingPolicyConfigurationUpdate = (input, context) => {
    return {
        ...(input.DisableScaleIn != null && { DisableScaleIn: input.DisableScaleIn }),
        ...(input.ScaleInCooldown != null && { ScaleInCooldown: input.ScaleInCooldown }),
        ...(input.ScaleOutCooldown != null && { ScaleOutCooldown: input.ScaleOutCooldown }),
        ...(input.TargetValue != null && { TargetValue: (0, smithy_client_1.serializeFloat)(input.TargetValue) }),
    };
};
const se_BatchExecuteStatementInput = (input, context) => {
    return {
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.Statements != null && { Statements: se_PartiQLBatchRequest(input.Statements, context) }),
    };
};
const se_BatchGetItemInput = (input, context) => {
    return {
        ...(input.RequestItems != null && { RequestItems: se_BatchGetRequestMap(input.RequestItems, context) }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
    };
};
const se_BatchGetRequestMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_KeysAndAttributes(value, context);
        return acc;
    }, {});
};
const se_BatchStatementRequest = (input, context) => {
    return {
        ...(input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead }),
        ...(input.Parameters != null && { Parameters: se_PreparedStatementParameters(input.Parameters, context) }),
        ...(input.Statement != null && { Statement: input.Statement }),
    };
};
const se_BatchWriteItemInput = (input, context) => {
    return {
        ...(input.RequestItems != null && { RequestItems: se_BatchWriteItemRequestMap(input.RequestItems, context) }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.ReturnItemCollectionMetrics != null && {
            ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics,
        }),
    };
};
const se_BatchWriteItemRequestMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_WriteRequests(value, context);
        return acc;
    }, {});
};
const se_BinarySetAttributeValue = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return context.base64Encoder(entry);
    });
};
const se_Condition = (input, context) => {
    return {
        ...(input.AttributeValueList != null && {
            AttributeValueList: se_AttributeValueList(input.AttributeValueList, context),
        }),
        ...(input.ComparisonOperator != null && { ComparisonOperator: input.ComparisonOperator }),
    };
};
const se_ConditionCheck = (input, context) => {
    return {
        ...(input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
        ...(input.ReturnValuesOnConditionCheckFailure != null && {
            ReturnValuesOnConditionCheckFailure: input.ReturnValuesOnConditionCheckFailure,
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_CreateBackupInput = (input, context) => {
    return {
        ...(input.BackupName != null && { BackupName: input.BackupName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_CreateGlobalSecondaryIndexAction = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.KeySchema != null && { KeySchema: se_KeySchema(input.KeySchema, context) }),
        ...(input.Projection != null && { Projection: se_Projection(input.Projection, context) }),
        ...(input.ProvisionedThroughput != null && {
            ProvisionedThroughput: se_ProvisionedThroughput(input.ProvisionedThroughput, context),
        }),
    };
};
const se_CreateGlobalTableInput = (input, context) => {
    return {
        ...(input.GlobalTableName != null && { GlobalTableName: input.GlobalTableName }),
        ...(input.ReplicationGroup != null && { ReplicationGroup: se_ReplicaList(input.ReplicationGroup, context) }),
    };
};
const se_CreateReplicaAction = (input, context) => {
    return {
        ...(input.RegionName != null && { RegionName: input.RegionName }),
    };
};
const se_CreateReplicationGroupMemberAction = (input, context) => {
    return {
        ...(input.GlobalSecondaryIndexes != null && {
            GlobalSecondaryIndexes: se_ReplicaGlobalSecondaryIndexList(input.GlobalSecondaryIndexes, context),
        }),
        ...(input.KMSMasterKeyId != null && { KMSMasterKeyId: input.KMSMasterKeyId }),
        ...(input.ProvisionedThroughputOverride != null && {
            ProvisionedThroughputOverride: se_ProvisionedThroughputOverride(input.ProvisionedThroughputOverride, context),
        }),
        ...(input.RegionName != null && { RegionName: input.RegionName }),
        ...(input.TableClassOverride != null && { TableClassOverride: input.TableClassOverride }),
    };
};
const se_CreateTableInput = (input, context) => {
    return {
        ...(input.AttributeDefinitions != null && {
            AttributeDefinitions: se_AttributeDefinitions(input.AttributeDefinitions, context),
        }),
        ...(input.BillingMode != null && { BillingMode: input.BillingMode }),
        ...(input.DeletionProtectionEnabled != null && { DeletionProtectionEnabled: input.DeletionProtectionEnabled }),
        ...(input.GlobalSecondaryIndexes != null && {
            GlobalSecondaryIndexes: se_GlobalSecondaryIndexList(input.GlobalSecondaryIndexes, context),
        }),
        ...(input.KeySchema != null && { KeySchema: se_KeySchema(input.KeySchema, context) }),
        ...(input.LocalSecondaryIndexes != null && {
            LocalSecondaryIndexes: se_LocalSecondaryIndexList(input.LocalSecondaryIndexes, context),
        }),
        ...(input.ProvisionedThroughput != null && {
            ProvisionedThroughput: se_ProvisionedThroughput(input.ProvisionedThroughput, context),
        }),
        ...(input.SSESpecification != null && { SSESpecification: se_SSESpecification(input.SSESpecification, context) }),
        ...(input.StreamSpecification != null && {
            StreamSpecification: se_StreamSpecification(input.StreamSpecification, context),
        }),
        ...(input.TableClass != null && { TableClass: input.TableClass }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_CsvHeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_CsvOptions = (input, context) => {
    return {
        ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
        ...(input.HeaderList != null && { HeaderList: se_CsvHeaderList(input.HeaderList, context) }),
    };
};
const se_Delete = (input, context) => {
    return {
        ...(input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
        ...(input.ReturnValuesOnConditionCheckFailure != null && {
            ReturnValuesOnConditionCheckFailure: input.ReturnValuesOnConditionCheckFailure,
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DeleteBackupInput = (input, context) => {
    return {
        ...(input.BackupArn != null && { BackupArn: input.BackupArn }),
    };
};
const se_DeleteGlobalSecondaryIndexAction = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
    };
};
const se_DeleteItemInput = (input, context) => {
    return {
        ...(input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression }),
        ...(input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator }),
        ...(input.Expected != null && { Expected: se_ExpectedAttributeMap(input.Expected, context) }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.ReturnItemCollectionMetrics != null && {
            ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics,
        }),
        ...(input.ReturnValues != null && { ReturnValues: input.ReturnValues }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DeleteReplicaAction = (input, context) => {
    return {
        ...(input.RegionName != null && { RegionName: input.RegionName }),
    };
};
const se_DeleteReplicationGroupMemberAction = (input, context) => {
    return {
        ...(input.RegionName != null && { RegionName: input.RegionName }),
    };
};
const se_DeleteRequest = (input, context) => {
    return {
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
    };
};
const se_DeleteTableInput = (input, context) => {
    return {
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DescribeBackupInput = (input, context) => {
    return {
        ...(input.BackupArn != null && { BackupArn: input.BackupArn }),
    };
};
const se_DescribeContinuousBackupsInput = (input, context) => {
    return {
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DescribeContributorInsightsInput = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DescribeEndpointsRequest = (input, context) => {
    return {};
};
const se_DescribeExportInput = (input, context) => {
    return {
        ...(input.ExportArn != null && { ExportArn: input.ExportArn }),
    };
};
const se_DescribeGlobalTableInput = (input, context) => {
    return {
        ...(input.GlobalTableName != null && { GlobalTableName: input.GlobalTableName }),
    };
};
const se_DescribeGlobalTableSettingsInput = (input, context) => {
    return {
        ...(input.GlobalTableName != null && { GlobalTableName: input.GlobalTableName }),
    };
};
const se_DescribeImportInput = (input, context) => {
    return {
        ...(input.ImportArn != null && { ImportArn: input.ImportArn }),
    };
};
const se_DescribeKinesisStreamingDestinationInput = (input, context) => {
    return {
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DescribeLimitsInput = (input, context) => {
    return {};
};
const se_DescribeTableInput = (input, context) => {
    return {
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DescribeTableReplicaAutoScalingInput = (input, context) => {
    return {
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_DescribeTimeToLiveInput = (input, context) => {
    return {
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_ExecuteStatementInput = (input, context) => {
    return {
        ...(input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Parameters != null && { Parameters: se_PreparedStatementParameters(input.Parameters, context) }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.Statement != null && { Statement: input.Statement }),
    };
};
const se_ExecuteTransactionInput = (input, context) => {
    return {
        ClientRequestToken: input.ClientRequestToken ?? (0, uuid_1.v4)(),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.TransactStatements != null && {
            TransactStatements: se_ParameterizedStatements(input.TransactStatements, context),
        }),
    };
};
const se_ExpectedAttributeMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ExpectedAttributeValue(value, context);
        return acc;
    }, {});
};
const se_ExpectedAttributeValue = (input, context) => {
    return {
        ...(input.AttributeValueList != null && {
            AttributeValueList: se_AttributeValueList(input.AttributeValueList, context),
        }),
        ...(input.ComparisonOperator != null && { ComparisonOperator: input.ComparisonOperator }),
        ...(input.Exists != null && { Exists: input.Exists }),
        ...(input.Value != null && { Value: se_AttributeValue(input.Value, context) }),
    };
};
const se_ExportTableToPointInTimeInput = (input, context) => {
    return {
        ClientToken: input.ClientToken ?? (0, uuid_1.v4)(),
        ...(input.ExportFormat != null && { ExportFormat: input.ExportFormat }),
        ...(input.ExportTime != null && { ExportTime: Math.round(input.ExportTime.getTime() / 1000) }),
        ...(input.S3Bucket != null && { S3Bucket: input.S3Bucket }),
        ...(input.S3BucketOwner != null && { S3BucketOwner: input.S3BucketOwner }),
        ...(input.S3Prefix != null && { S3Prefix: input.S3Prefix }),
        ...(input.S3SseAlgorithm != null && { S3SseAlgorithm: input.S3SseAlgorithm }),
        ...(input.S3SseKmsKeyId != null && { S3SseKmsKeyId: input.S3SseKmsKeyId }),
        ...(input.TableArn != null && { TableArn: input.TableArn }),
    };
};
const se_ExpressionAttributeNameMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const se_ExpressionAttributeValueMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_FilterConditionMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Condition(value, context);
        return acc;
    }, {});
};
const se_Get = (input, context) => {
    return {
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
        ...(input.ProjectionExpression != null && { ProjectionExpression: input.ProjectionExpression }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_GetItemInput = (input, context) => {
    return {
        ...(input.AttributesToGet != null && { AttributesToGet: se_AttributeNameList(input.AttributesToGet, context) }),
        ...(input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
        ...(input.ProjectionExpression != null && { ProjectionExpression: input.ProjectionExpression }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_GlobalSecondaryIndex = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.KeySchema != null && { KeySchema: se_KeySchema(input.KeySchema, context) }),
        ...(input.Projection != null && { Projection: se_Projection(input.Projection, context) }),
        ...(input.ProvisionedThroughput != null && {
            ProvisionedThroughput: se_ProvisionedThroughput(input.ProvisionedThroughput, context),
        }),
    };
};
const se_GlobalSecondaryIndexAutoScalingUpdate = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.ProvisionedWriteCapacityAutoScalingUpdate != null && {
            ProvisionedWriteCapacityAutoScalingUpdate: se_AutoScalingSettingsUpdate(input.ProvisionedWriteCapacityAutoScalingUpdate, context),
        }),
    };
};
const se_GlobalSecondaryIndexAutoScalingUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GlobalSecondaryIndexAutoScalingUpdate(entry, context);
    });
};
const se_GlobalSecondaryIndexList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GlobalSecondaryIndex(entry, context);
    });
};
const se_GlobalSecondaryIndexUpdate = (input, context) => {
    return {
        ...(input.Create != null && { Create: se_CreateGlobalSecondaryIndexAction(input.Create, context) }),
        ...(input.Delete != null && { Delete: se_DeleteGlobalSecondaryIndexAction(input.Delete, context) }),
        ...(input.Update != null && { Update: se_UpdateGlobalSecondaryIndexAction(input.Update, context) }),
    };
};
const se_GlobalSecondaryIndexUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GlobalSecondaryIndexUpdate(entry, context);
    });
};
const se_GlobalTableGlobalSecondaryIndexSettingsUpdate = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.ProvisionedWriteCapacityAutoScalingSettingsUpdate != null && {
            ProvisionedWriteCapacityAutoScalingSettingsUpdate: se_AutoScalingSettingsUpdate(input.ProvisionedWriteCapacityAutoScalingSettingsUpdate, context),
        }),
        ...(input.ProvisionedWriteCapacityUnits != null && {
            ProvisionedWriteCapacityUnits: input.ProvisionedWriteCapacityUnits,
        }),
    };
};
const se_GlobalTableGlobalSecondaryIndexSettingsUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GlobalTableGlobalSecondaryIndexSettingsUpdate(entry, context);
    });
};
const se_ImportTableInput = (input, context) => {
    return {
        ClientToken: input.ClientToken ?? (0, uuid_1.v4)(),
        ...(input.InputCompressionType != null && { InputCompressionType: input.InputCompressionType }),
        ...(input.InputFormat != null && { InputFormat: input.InputFormat }),
        ...(input.InputFormatOptions != null && {
            InputFormatOptions: se_InputFormatOptions(input.InputFormatOptions, context),
        }),
        ...(input.S3BucketSource != null && { S3BucketSource: se_S3BucketSource(input.S3BucketSource, context) }),
        ...(input.TableCreationParameters != null && {
            TableCreationParameters: se_TableCreationParameters(input.TableCreationParameters, context),
        }),
    };
};
const se_InputFormatOptions = (input, context) => {
    return {
        ...(input.Csv != null && { Csv: se_CsvOptions(input.Csv, context) }),
    };
};
const se_Key = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_KeyConditions = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Condition(value, context);
        return acc;
    }, {});
};
const se_KeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Key(entry, context);
    });
};
const se_KeysAndAttributes = (input, context) => {
    return {
        ...(input.AttributesToGet != null && { AttributesToGet: se_AttributeNameList(input.AttributesToGet, context) }),
        ...(input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.Keys != null && { Keys: se_KeyList(input.Keys, context) }),
        ...(input.ProjectionExpression != null && { ProjectionExpression: input.ProjectionExpression }),
    };
};
const se_KeySchema = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_KeySchemaElement(entry, context);
    });
};
const se_KeySchemaElement = (input, context) => {
    return {
        ...(input.AttributeName != null && { AttributeName: input.AttributeName }),
        ...(input.KeyType != null && { KeyType: input.KeyType }),
    };
};
const se_KinesisStreamingDestinationInput = (input, context) => {
    return {
        ...(input.StreamArn != null && { StreamArn: input.StreamArn }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_ListAttributeValue = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeValue(entry, context);
    });
};
const se_ListBackupsInput = (input, context) => {
    return {
        ...(input.BackupType != null && { BackupType: input.BackupType }),
        ...(input.ExclusiveStartBackupArn != null && { ExclusiveStartBackupArn: input.ExclusiveStartBackupArn }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.TimeRangeLowerBound != null && {
            TimeRangeLowerBound: Math.round(input.TimeRangeLowerBound.getTime() / 1000),
        }),
        ...(input.TimeRangeUpperBound != null && {
            TimeRangeUpperBound: Math.round(input.TimeRangeUpperBound.getTime() / 1000),
        }),
    };
};
const se_ListContributorInsightsInput = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_ListExportsInput = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.TableArn != null && { TableArn: input.TableArn }),
    };
};
const se_ListGlobalTablesInput = (input, context) => {
    return {
        ...(input.ExclusiveStartGlobalTableName != null && {
            ExclusiveStartGlobalTableName: input.ExclusiveStartGlobalTableName,
        }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.RegionName != null && { RegionName: input.RegionName }),
    };
};
const se_ListImportsInput = (input, context) => {
    return {
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.PageSize != null && { PageSize: input.PageSize }),
        ...(input.TableArn != null && { TableArn: input.TableArn }),
    };
};
const se_ListTablesInput = (input, context) => {
    return {
        ...(input.ExclusiveStartTableName != null && { ExclusiveStartTableName: input.ExclusiveStartTableName }),
        ...(input.Limit != null && { Limit: input.Limit }),
    };
};
const se_ListTagsOfResourceInput = (input, context) => {
    return {
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const se_LocalSecondaryIndex = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.KeySchema != null && { KeySchema: se_KeySchema(input.KeySchema, context) }),
        ...(input.Projection != null && { Projection: se_Projection(input.Projection, context) }),
    };
};
const se_LocalSecondaryIndexList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_LocalSecondaryIndex(entry, context);
    });
};
const se_MapAttributeValue = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_NonKeyAttributeNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_NumberSetAttributeValue = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_ParameterizedStatement = (input, context) => {
    return {
        ...(input.Parameters != null && { Parameters: se_PreparedStatementParameters(input.Parameters, context) }),
        ...(input.Statement != null && { Statement: input.Statement }),
    };
};
const se_ParameterizedStatements = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ParameterizedStatement(entry, context);
    });
};
const se_PartiQLBatchRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BatchStatementRequest(entry, context);
    });
};
const se_PointInTimeRecoverySpecification = (input, context) => {
    return {
        ...(input.PointInTimeRecoveryEnabled != null && { PointInTimeRecoveryEnabled: input.PointInTimeRecoveryEnabled }),
    };
};
const se_PreparedStatementParameters = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeValue(entry, context);
    });
};
const se_Projection = (input, context) => {
    return {
        ...(input.NonKeyAttributes != null && {
            NonKeyAttributes: se_NonKeyAttributeNameList(input.NonKeyAttributes, context),
        }),
        ...(input.ProjectionType != null && { ProjectionType: input.ProjectionType }),
    };
};
const se_ProvisionedThroughput = (input, context) => {
    return {
        ...(input.ReadCapacityUnits != null && { ReadCapacityUnits: input.ReadCapacityUnits }),
        ...(input.WriteCapacityUnits != null && { WriteCapacityUnits: input.WriteCapacityUnits }),
    };
};
const se_ProvisionedThroughputOverride = (input, context) => {
    return {
        ...(input.ReadCapacityUnits != null && { ReadCapacityUnits: input.ReadCapacityUnits }),
    };
};
const se_Put = (input, context) => {
    return {
        ...(input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.Item != null && { Item: se_PutItemInputAttributeMap(input.Item, context) }),
        ...(input.ReturnValuesOnConditionCheckFailure != null && {
            ReturnValuesOnConditionCheckFailure: input.ReturnValuesOnConditionCheckFailure,
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_PutItemInput = (input, context) => {
    return {
        ...(input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression }),
        ...(input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator }),
        ...(input.Expected != null && { Expected: se_ExpectedAttributeMap(input.Expected, context) }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.Item != null && { Item: se_PutItemInputAttributeMap(input.Item, context) }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.ReturnItemCollectionMetrics != null && {
            ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics,
        }),
        ...(input.ReturnValues != null && { ReturnValues: input.ReturnValues }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_PutItemInputAttributeMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_PutRequest = (input, context) => {
    return {
        ...(input.Item != null && { Item: se_PutItemInputAttributeMap(input.Item, context) }),
    };
};
const se_QueryInput = (input, context) => {
    return {
        ...(input.AttributesToGet != null && { AttributesToGet: se_AttributeNameList(input.AttributesToGet, context) }),
        ...(input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator }),
        ...(input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead }),
        ...(input.ExclusiveStartKey != null && { ExclusiveStartKey: se_Key(input.ExclusiveStartKey, context) }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.FilterExpression != null && { FilterExpression: input.FilterExpression }),
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.KeyConditionExpression != null && { KeyConditionExpression: input.KeyConditionExpression }),
        ...(input.KeyConditions != null && { KeyConditions: se_KeyConditions(input.KeyConditions, context) }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.ProjectionExpression != null && { ProjectionExpression: input.ProjectionExpression }),
        ...(input.QueryFilter != null && { QueryFilter: se_FilterConditionMap(input.QueryFilter, context) }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.ScanIndexForward != null && { ScanIndexForward: input.ScanIndexForward }),
        ...(input.Select != null && { Select: input.Select }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_Replica = (input, context) => {
    return {
        ...(input.RegionName != null && { RegionName: input.RegionName }),
    };
};
const se_ReplicaAutoScalingUpdate = (input, context) => {
    return {
        ...(input.RegionName != null && { RegionName: input.RegionName }),
        ...(input.ReplicaGlobalSecondaryIndexUpdates != null && {
            ReplicaGlobalSecondaryIndexUpdates: se_ReplicaGlobalSecondaryIndexAutoScalingUpdateList(input.ReplicaGlobalSecondaryIndexUpdates, context),
        }),
        ...(input.ReplicaProvisionedReadCapacityAutoScalingUpdate != null && {
            ReplicaProvisionedReadCapacityAutoScalingUpdate: se_AutoScalingSettingsUpdate(input.ReplicaProvisionedReadCapacityAutoScalingUpdate, context),
        }),
    };
};
const se_ReplicaAutoScalingUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaAutoScalingUpdate(entry, context);
    });
};
const se_ReplicaGlobalSecondaryIndex = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.ProvisionedThroughputOverride != null && {
            ProvisionedThroughputOverride: se_ProvisionedThroughputOverride(input.ProvisionedThroughputOverride, context),
        }),
    };
};
const se_ReplicaGlobalSecondaryIndexAutoScalingUpdate = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.ProvisionedReadCapacityAutoScalingUpdate != null && {
            ProvisionedReadCapacityAutoScalingUpdate: se_AutoScalingSettingsUpdate(input.ProvisionedReadCapacityAutoScalingUpdate, context),
        }),
    };
};
const se_ReplicaGlobalSecondaryIndexAutoScalingUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaGlobalSecondaryIndexAutoScalingUpdate(entry, context);
    });
};
const se_ReplicaGlobalSecondaryIndexList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaGlobalSecondaryIndex(entry, context);
    });
};
const se_ReplicaGlobalSecondaryIndexSettingsUpdate = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.ProvisionedReadCapacityAutoScalingSettingsUpdate != null && {
            ProvisionedReadCapacityAutoScalingSettingsUpdate: se_AutoScalingSettingsUpdate(input.ProvisionedReadCapacityAutoScalingSettingsUpdate, context),
        }),
        ...(input.ProvisionedReadCapacityUnits != null && {
            ProvisionedReadCapacityUnits: input.ProvisionedReadCapacityUnits,
        }),
    };
};
const se_ReplicaGlobalSecondaryIndexSettingsUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaGlobalSecondaryIndexSettingsUpdate(entry, context);
    });
};
const se_ReplicaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Replica(entry, context);
    });
};
const se_ReplicaSettingsUpdate = (input, context) => {
    return {
        ...(input.RegionName != null && { RegionName: input.RegionName }),
        ...(input.ReplicaGlobalSecondaryIndexSettingsUpdate != null && {
            ReplicaGlobalSecondaryIndexSettingsUpdate: se_ReplicaGlobalSecondaryIndexSettingsUpdateList(input.ReplicaGlobalSecondaryIndexSettingsUpdate, context),
        }),
        ...(input.ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate != null && {
            ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: se_AutoScalingSettingsUpdate(input.ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate, context),
        }),
        ...(input.ReplicaProvisionedReadCapacityUnits != null && {
            ReplicaProvisionedReadCapacityUnits: input.ReplicaProvisionedReadCapacityUnits,
        }),
        ...(input.ReplicaTableClass != null && { ReplicaTableClass: input.ReplicaTableClass }),
    };
};
const se_ReplicaSettingsUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaSettingsUpdate(entry, context);
    });
};
const se_ReplicationGroupUpdate = (input, context) => {
    return {
        ...(input.Create != null && { Create: se_CreateReplicationGroupMemberAction(input.Create, context) }),
        ...(input.Delete != null && { Delete: se_DeleteReplicationGroupMemberAction(input.Delete, context) }),
        ...(input.Update != null && { Update: se_UpdateReplicationGroupMemberAction(input.Update, context) }),
    };
};
const se_ReplicationGroupUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicationGroupUpdate(entry, context);
    });
};
const se_ReplicaUpdate = (input, context) => {
    return {
        ...(input.Create != null && { Create: se_CreateReplicaAction(input.Create, context) }),
        ...(input.Delete != null && { Delete: se_DeleteReplicaAction(input.Delete, context) }),
    };
};
const se_ReplicaUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaUpdate(entry, context);
    });
};
const se_RestoreTableFromBackupInput = (input, context) => {
    return {
        ...(input.BackupArn != null && { BackupArn: input.BackupArn }),
        ...(input.BillingModeOverride != null && { BillingModeOverride: input.BillingModeOverride }),
        ...(input.GlobalSecondaryIndexOverride != null && {
            GlobalSecondaryIndexOverride: se_GlobalSecondaryIndexList(input.GlobalSecondaryIndexOverride, context),
        }),
        ...(input.LocalSecondaryIndexOverride != null && {
            LocalSecondaryIndexOverride: se_LocalSecondaryIndexList(input.LocalSecondaryIndexOverride, context),
        }),
        ...(input.ProvisionedThroughputOverride != null && {
            ProvisionedThroughputOverride: se_ProvisionedThroughput(input.ProvisionedThroughputOverride, context),
        }),
        ...(input.SSESpecificationOverride != null && {
            SSESpecificationOverride: se_SSESpecification(input.SSESpecificationOverride, context),
        }),
        ...(input.TargetTableName != null && { TargetTableName: input.TargetTableName }),
    };
};
const se_RestoreTableToPointInTimeInput = (input, context) => {
    return {
        ...(input.BillingModeOverride != null && { BillingModeOverride: input.BillingModeOverride }),
        ...(input.GlobalSecondaryIndexOverride != null && {
            GlobalSecondaryIndexOverride: se_GlobalSecondaryIndexList(input.GlobalSecondaryIndexOverride, context),
        }),
        ...(input.LocalSecondaryIndexOverride != null && {
            LocalSecondaryIndexOverride: se_LocalSecondaryIndexList(input.LocalSecondaryIndexOverride, context),
        }),
        ...(input.ProvisionedThroughputOverride != null && {
            ProvisionedThroughputOverride: se_ProvisionedThroughput(input.ProvisionedThroughputOverride, context),
        }),
        ...(input.RestoreDateTime != null && { RestoreDateTime: Math.round(input.RestoreDateTime.getTime() / 1000) }),
        ...(input.SSESpecificationOverride != null && {
            SSESpecificationOverride: se_SSESpecification(input.SSESpecificationOverride, context),
        }),
        ...(input.SourceTableArn != null && { SourceTableArn: input.SourceTableArn }),
        ...(input.SourceTableName != null && { SourceTableName: input.SourceTableName }),
        ...(input.TargetTableName != null && { TargetTableName: input.TargetTableName }),
        ...(input.UseLatestRestorableTime != null && { UseLatestRestorableTime: input.UseLatestRestorableTime }),
    };
};
const se_S3BucketSource = (input, context) => {
    return {
        ...(input.S3Bucket != null && { S3Bucket: input.S3Bucket }),
        ...(input.S3BucketOwner != null && { S3BucketOwner: input.S3BucketOwner }),
        ...(input.S3KeyPrefix != null && { S3KeyPrefix: input.S3KeyPrefix }),
    };
};
const se_ScanInput = (input, context) => {
    return {
        ...(input.AttributesToGet != null && { AttributesToGet: se_AttributeNameList(input.AttributesToGet, context) }),
        ...(input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator }),
        ...(input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead }),
        ...(input.ExclusiveStartKey != null && { ExclusiveStartKey: se_Key(input.ExclusiveStartKey, context) }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.FilterExpression != null && { FilterExpression: input.FilterExpression }),
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.ProjectionExpression != null && { ProjectionExpression: input.ProjectionExpression }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.ScanFilter != null && { ScanFilter: se_FilterConditionMap(input.ScanFilter, context) }),
        ...(input.Segment != null && { Segment: input.Segment }),
        ...(input.Select != null && { Select: input.Select }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.TotalSegments != null && { TotalSegments: input.TotalSegments }),
    };
};
const se_SSESpecification = (input, context) => {
    return {
        ...(input.Enabled != null && { Enabled: input.Enabled }),
        ...(input.KMSMasterKeyId != null && { KMSMasterKeyId: input.KMSMasterKeyId }),
        ...(input.SSEType != null && { SSEType: input.SSEType }),
    };
};
const se_StreamSpecification = (input, context) => {
    return {
        ...(input.StreamEnabled != null && { StreamEnabled: input.StreamEnabled }),
        ...(input.StreamViewType != null && { StreamViewType: input.StreamViewType }),
    };
};
const se_StringSetAttributeValue = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_TableCreationParameters = (input, context) => {
    return {
        ...(input.AttributeDefinitions != null && {
            AttributeDefinitions: se_AttributeDefinitions(input.AttributeDefinitions, context),
        }),
        ...(input.BillingMode != null && { BillingMode: input.BillingMode }),
        ...(input.GlobalSecondaryIndexes != null && {
            GlobalSecondaryIndexes: se_GlobalSecondaryIndexList(input.GlobalSecondaryIndexes, context),
        }),
        ...(input.KeySchema != null && { KeySchema: se_KeySchema(input.KeySchema, context) }),
        ...(input.ProvisionedThroughput != null && {
            ProvisionedThroughput: se_ProvisionedThroughput(input.ProvisionedThroughput, context),
        }),
        ...(input.SSESpecification != null && { SSESpecification: se_SSESpecification(input.SSESpecification, context) }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_Tag = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Tag(entry, context);
    });
};
const se_TagResourceInput = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_TimeToLiveSpecification = (input, context) => {
    return {
        ...(input.AttributeName != null && { AttributeName: input.AttributeName }),
        ...(input.Enabled != null && { Enabled: input.Enabled }),
    };
};
const se_TransactGetItem = (input, context) => {
    return {
        ...(input.Get != null && { Get: se_Get(input.Get, context) }),
    };
};
const se_TransactGetItemList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TransactGetItem(entry, context);
    });
};
const se_TransactGetItemsInput = (input, context) => {
    return {
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.TransactItems != null && { TransactItems: se_TransactGetItemList(input.TransactItems, context) }),
    };
};
const se_TransactWriteItem = (input, context) => {
    return {
        ...(input.ConditionCheck != null && { ConditionCheck: se_ConditionCheck(input.ConditionCheck, context) }),
        ...(input.Delete != null && { Delete: se_Delete(input.Delete, context) }),
        ...(input.Put != null && { Put: se_Put(input.Put, context) }),
        ...(input.Update != null && { Update: se_Update(input.Update, context) }),
    };
};
const se_TransactWriteItemList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TransactWriteItem(entry, context);
    });
};
const se_TransactWriteItemsInput = (input, context) => {
    return {
        ClientRequestToken: input.ClientRequestToken ?? (0, uuid_1.v4)(),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.ReturnItemCollectionMetrics != null && {
            ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics,
        }),
        ...(input.TransactItems != null && { TransactItems: se_TransactWriteItemList(input.TransactItems, context) }),
    };
};
const se_UntagResourceInput = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
        ...(input.TagKeys != null && { TagKeys: se_TagKeyList(input.TagKeys, context) }),
    };
};
const se_Update = (input, context) => {
    return {
        ...(input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
        ...(input.ReturnValuesOnConditionCheckFailure != null && {
            ReturnValuesOnConditionCheckFailure: input.ReturnValuesOnConditionCheckFailure,
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.UpdateExpression != null && { UpdateExpression: input.UpdateExpression }),
    };
};
const se_UpdateContinuousBackupsInput = (input, context) => {
    return {
        ...(input.PointInTimeRecoverySpecification != null && {
            PointInTimeRecoverySpecification: se_PointInTimeRecoverySpecification(input.PointInTimeRecoverySpecification, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_UpdateContributorInsightsInput = (input, context) => {
    return {
        ...(input.ContributorInsightsAction != null && { ContributorInsightsAction: input.ContributorInsightsAction }),
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_UpdateGlobalSecondaryIndexAction = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.ProvisionedThroughput != null && {
            ProvisionedThroughput: se_ProvisionedThroughput(input.ProvisionedThroughput, context),
        }),
    };
};
const se_UpdateGlobalTableInput = (input, context) => {
    return {
        ...(input.GlobalTableName != null && { GlobalTableName: input.GlobalTableName }),
        ...(input.ReplicaUpdates != null && { ReplicaUpdates: se_ReplicaUpdateList(input.ReplicaUpdates, context) }),
    };
};
const se_UpdateGlobalTableSettingsInput = (input, context) => {
    return {
        ...(input.GlobalTableBillingMode != null && { GlobalTableBillingMode: input.GlobalTableBillingMode }),
        ...(input.GlobalTableGlobalSecondaryIndexSettingsUpdate != null && {
            GlobalTableGlobalSecondaryIndexSettingsUpdate: se_GlobalTableGlobalSecondaryIndexSettingsUpdateList(input.GlobalTableGlobalSecondaryIndexSettingsUpdate, context),
        }),
        ...(input.GlobalTableName != null && { GlobalTableName: input.GlobalTableName }),
        ...(input.GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate != null && {
            GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: se_AutoScalingSettingsUpdate(input.GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate, context),
        }),
        ...(input.GlobalTableProvisionedWriteCapacityUnits != null && {
            GlobalTableProvisionedWriteCapacityUnits: input.GlobalTableProvisionedWriteCapacityUnits,
        }),
        ...(input.ReplicaSettingsUpdate != null && {
            ReplicaSettingsUpdate: se_ReplicaSettingsUpdateList(input.ReplicaSettingsUpdate, context),
        }),
    };
};
const se_UpdateItemInput = (input, context) => {
    return {
        ...(input.AttributeUpdates != null && { AttributeUpdates: se_AttributeUpdates(input.AttributeUpdates, context) }),
        ...(input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression }),
        ...(input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator }),
        ...(input.Expected != null && { Expected: se_ExpectedAttributeMap(input.Expected, context) }),
        ...(input.ExpressionAttributeNames != null && {
            ExpressionAttributeNames: se_ExpressionAttributeNameMap(input.ExpressionAttributeNames, context),
        }),
        ...(input.ExpressionAttributeValues != null && {
            ExpressionAttributeValues: se_ExpressionAttributeValueMap(input.ExpressionAttributeValues, context),
        }),
        ...(input.Key != null && { Key: se_Key(input.Key, context) }),
        ...(input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }),
        ...(input.ReturnItemCollectionMetrics != null && {
            ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics,
        }),
        ...(input.ReturnValues != null && { ReturnValues: input.ReturnValues }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.UpdateExpression != null && { UpdateExpression: input.UpdateExpression }),
    };
};
const se_UpdateReplicationGroupMemberAction = (input, context) => {
    return {
        ...(input.GlobalSecondaryIndexes != null && {
            GlobalSecondaryIndexes: se_ReplicaGlobalSecondaryIndexList(input.GlobalSecondaryIndexes, context),
        }),
        ...(input.KMSMasterKeyId != null && { KMSMasterKeyId: input.KMSMasterKeyId }),
        ...(input.ProvisionedThroughputOverride != null && {
            ProvisionedThroughputOverride: se_ProvisionedThroughputOverride(input.ProvisionedThroughputOverride, context),
        }),
        ...(input.RegionName != null && { RegionName: input.RegionName }),
        ...(input.TableClassOverride != null && { TableClassOverride: input.TableClassOverride }),
    };
};
const se_UpdateTableInput = (input, context) => {
    return {
        ...(input.AttributeDefinitions != null && {
            AttributeDefinitions: se_AttributeDefinitions(input.AttributeDefinitions, context),
        }),
        ...(input.BillingMode != null && { BillingMode: input.BillingMode }),
        ...(input.DeletionProtectionEnabled != null && { DeletionProtectionEnabled: input.DeletionProtectionEnabled }),
        ...(input.GlobalSecondaryIndexUpdates != null && {
            GlobalSecondaryIndexUpdates: se_GlobalSecondaryIndexUpdateList(input.GlobalSecondaryIndexUpdates, context),
        }),
        ...(input.ProvisionedThroughput != null && {
            ProvisionedThroughput: se_ProvisionedThroughput(input.ProvisionedThroughput, context),
        }),
        ...(input.ReplicaUpdates != null && {
            ReplicaUpdates: se_ReplicationGroupUpdateList(input.ReplicaUpdates, context),
        }),
        ...(input.SSESpecification != null && { SSESpecification: se_SSESpecification(input.SSESpecification, context) }),
        ...(input.StreamSpecification != null && {
            StreamSpecification: se_StreamSpecification(input.StreamSpecification, context),
        }),
        ...(input.TableClass != null && { TableClass: input.TableClass }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_UpdateTableReplicaAutoScalingInput = (input, context) => {
    return {
        ...(input.GlobalSecondaryIndexUpdates != null && {
            GlobalSecondaryIndexUpdates: se_GlobalSecondaryIndexAutoScalingUpdateList(input.GlobalSecondaryIndexUpdates, context),
        }),
        ...(input.ProvisionedWriteCapacityAutoScalingUpdate != null && {
            ProvisionedWriteCapacityAutoScalingUpdate: se_AutoScalingSettingsUpdate(input.ProvisionedWriteCapacityAutoScalingUpdate, context),
        }),
        ...(input.ReplicaUpdates != null && {
            ReplicaUpdates: se_ReplicaAutoScalingUpdateList(input.ReplicaUpdates, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const se_UpdateTimeToLiveInput = (input, context) => {
    return {
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.TimeToLiveSpecification != null && {
            TimeToLiveSpecification: se_TimeToLiveSpecification(input.TimeToLiveSpecification, context),
        }),
    };
};
const se_WriteRequest = (input, context) => {
    return {
        ...(input.DeleteRequest != null && { DeleteRequest: se_DeleteRequest(input.DeleteRequest, context) }),
        ...(input.PutRequest != null && { PutRequest: se_PutRequest(input.PutRequest, context) }),
    };
};
const se_WriteRequests = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_WriteRequest(entry, context);
    });
};
const de_ArchivalSummary = (output, context) => {
    return {
        ArchivalBackupArn: (0, smithy_client_1.expectString)(output.ArchivalBackupArn),
        ArchivalDateTime: output.ArchivalDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.ArchivalDateTime)))
            : undefined,
        ArchivalReason: (0, smithy_client_1.expectString)(output.ArchivalReason),
    };
};
const de_AttributeDefinition = (output, context) => {
    return {
        AttributeName: (0, smithy_client_1.expectString)(output.AttributeName),
        AttributeType: (0, smithy_client_1.expectString)(output.AttributeType),
    };
};
const de_AttributeDefinitions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AttributeDefinition(entry, context);
    });
    return retVal;
};
const de_AttributeMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0, smithy_client_1.expectUnion)(value), context);
        return acc;
    }, {});
};
const de_AttributeNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const de_AttributeValue = (output, context) => {
    if (output.B != null) {
        return {
            B: context.base64Decoder(output.B),
        };
    }
    if ((0, smithy_client_1.expectBoolean)(output.BOOL) !== undefined) {
        return { BOOL: (0, smithy_client_1.expectBoolean)(output.BOOL) };
    }
    if (output.BS != null) {
        return {
            BS: de_BinarySetAttributeValue(output.BS, context),
        };
    }
    if (output.L != null) {
        return {
            L: de_ListAttributeValue(output.L, context),
        };
    }
    if (output.M != null) {
        return {
            M: de_MapAttributeValue(output.M, context),
        };
    }
    if ((0, smithy_client_1.expectString)(output.N) !== undefined) {
        return { N: (0, smithy_client_1.expectString)(output.N) };
    }
    if (output.NS != null) {
        return {
            NS: de_NumberSetAttributeValue(output.NS, context),
        };
    }
    if ((0, smithy_client_1.expectBoolean)(output.NULL) !== undefined) {
        return { NULL: (0, smithy_client_1.expectBoolean)(output.NULL) };
    }
    if ((0, smithy_client_1.expectString)(output.S) !== undefined) {
        return { S: (0, smithy_client_1.expectString)(output.S) };
    }
    if (output.SS != null) {
        return {
            SS: de_StringSetAttributeValue(output.SS, context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_AutoScalingPolicyDescription = (output, context) => {
    return {
        PolicyName: (0, smithy_client_1.expectString)(output.PolicyName),
        TargetTrackingScalingPolicyConfiguration: output.TargetTrackingScalingPolicyConfiguration != null
            ? de_AutoScalingTargetTrackingScalingPolicyConfigurationDescription(output.TargetTrackingScalingPolicyConfiguration, context)
            : undefined,
    };
};
const de_AutoScalingPolicyDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AutoScalingPolicyDescription(entry, context);
    });
    return retVal;
};
const de_AutoScalingSettingsDescription = (output, context) => {
    return {
        AutoScalingDisabled: (0, smithy_client_1.expectBoolean)(output.AutoScalingDisabled),
        AutoScalingRoleArn: (0, smithy_client_1.expectString)(output.AutoScalingRoleArn),
        MaximumUnits: (0, smithy_client_1.expectLong)(output.MaximumUnits),
        MinimumUnits: (0, smithy_client_1.expectLong)(output.MinimumUnits),
        ScalingPolicies: output.ScalingPolicies != null ? de_AutoScalingPolicyDescriptionList(output.ScalingPolicies, context) : undefined,
    };
};
const de_AutoScalingTargetTrackingScalingPolicyConfigurationDescription = (output, context) => {
    return {
        DisableScaleIn: (0, smithy_client_1.expectBoolean)(output.DisableScaleIn),
        ScaleInCooldown: (0, smithy_client_1.expectInt32)(output.ScaleInCooldown),
        ScaleOutCooldown: (0, smithy_client_1.expectInt32)(output.ScaleOutCooldown),
        TargetValue: (0, smithy_client_1.limitedParseDouble)(output.TargetValue),
    };
};
const de_BackupDescription = (output, context) => {
    return {
        BackupDetails: output.BackupDetails != null ? de_BackupDetails(output.BackupDetails, context) : undefined,
        SourceTableDetails: output.SourceTableDetails != null ? de_SourceTableDetails(output.SourceTableDetails, context) : undefined,
        SourceTableFeatureDetails: output.SourceTableFeatureDetails != null
            ? de_SourceTableFeatureDetails(output.SourceTableFeatureDetails, context)
            : undefined,
    };
};
const de_BackupDetails = (output, context) => {
    return {
        BackupArn: (0, smithy_client_1.expectString)(output.BackupArn),
        BackupCreationDateTime: output.BackupCreationDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.BackupCreationDateTime)))
            : undefined,
        BackupExpiryDateTime: output.BackupExpiryDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.BackupExpiryDateTime)))
            : undefined,
        BackupName: (0, smithy_client_1.expectString)(output.BackupName),
        BackupSizeBytes: (0, smithy_client_1.expectLong)(output.BackupSizeBytes),
        BackupStatus: (0, smithy_client_1.expectString)(output.BackupStatus),
        BackupType: (0, smithy_client_1.expectString)(output.BackupType),
    };
};
const de_BackupInUseException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_BackupNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_BackupSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_BackupSummary(entry, context);
    });
    return retVal;
};
const de_BackupSummary = (output, context) => {
    return {
        BackupArn: (0, smithy_client_1.expectString)(output.BackupArn),
        BackupCreationDateTime: output.BackupCreationDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.BackupCreationDateTime)))
            : undefined,
        BackupExpiryDateTime: output.BackupExpiryDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.BackupExpiryDateTime)))
            : undefined,
        BackupName: (0, smithy_client_1.expectString)(output.BackupName),
        BackupSizeBytes: (0, smithy_client_1.expectLong)(output.BackupSizeBytes),
        BackupStatus: (0, smithy_client_1.expectString)(output.BackupStatus),
        BackupType: (0, smithy_client_1.expectString)(output.BackupType),
        TableArn: (0, smithy_client_1.expectString)(output.TableArn),
        TableId: (0, smithy_client_1.expectString)(output.TableId),
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_BatchExecuteStatementOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacityMultiple(output.ConsumedCapacity, context) : undefined,
        Responses: output.Responses != null ? de_PartiQLBatchResponse(output.Responses, context) : undefined,
    };
};
const de_BatchGetItemOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacityMultiple(output.ConsumedCapacity, context) : undefined,
        Responses: output.Responses != null ? de_BatchGetResponseMap(output.Responses, context) : undefined,
        UnprocessedKeys: output.UnprocessedKeys != null ? de_BatchGetRequestMap(output.UnprocessedKeys, context) : undefined,
    };
};
const de_BatchGetRequestMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_KeysAndAttributes(value, context);
        return acc;
    }, {});
};
const de_BatchGetResponseMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ItemList(value, context);
        return acc;
    }, {});
};
const de_BatchStatementError = (output, context) => {
    return {
        Code: (0, smithy_client_1.expectString)(output.Code),
        Message: (0, smithy_client_1.expectString)(output.Message),
    };
};
const de_BatchStatementResponse = (output, context) => {
    return {
        Error: output.Error != null ? de_BatchStatementError(output.Error, context) : undefined,
        Item: output.Item != null ? de_AttributeMap(output.Item, context) : undefined,
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_BatchWriteItemOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacityMultiple(output.ConsumedCapacity, context) : undefined,
        ItemCollectionMetrics: output.ItemCollectionMetrics != null
            ? de_ItemCollectionMetricsPerTable(output.ItemCollectionMetrics, context)
            : undefined,
        UnprocessedItems: output.UnprocessedItems != null ? de_BatchWriteItemRequestMap(output.UnprocessedItems, context) : undefined,
    };
};
const de_BatchWriteItemRequestMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_WriteRequests(value, context);
        return acc;
    }, {});
};
const de_BillingModeSummary = (output, context) => {
    return {
        BillingMode: (0, smithy_client_1.expectString)(output.BillingMode),
        LastUpdateToPayPerRequestDateTime: output.LastUpdateToPayPerRequestDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdateToPayPerRequestDateTime)))
            : undefined,
    };
};
const de_BinarySetAttributeValue = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return context.base64Decoder(entry);
    });
    return retVal;
};
const de_CancellationReason = (output, context) => {
    return {
        Code: (0, smithy_client_1.expectString)(output.Code),
        Item: output.Item != null ? de_AttributeMap(output.Item, context) : undefined,
        Message: (0, smithy_client_1.expectString)(output.Message),
    };
};
const de_CancellationReasonList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_CancellationReason(entry, context);
    });
    return retVal;
};
const de_Capacity = (output, context) => {
    return {
        CapacityUnits: (0, smithy_client_1.limitedParseDouble)(output.CapacityUnits),
        ReadCapacityUnits: (0, smithy_client_1.limitedParseDouble)(output.ReadCapacityUnits),
        WriteCapacityUnits: (0, smithy_client_1.limitedParseDouble)(output.WriteCapacityUnits),
    };
};
const de_ConditionalCheckFailedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ConsumedCapacity = (output, context) => {
    return {
        CapacityUnits: (0, smithy_client_1.limitedParseDouble)(output.CapacityUnits),
        GlobalSecondaryIndexes: output.GlobalSecondaryIndexes != null
            ? de_SecondaryIndexesCapacityMap(output.GlobalSecondaryIndexes, context)
            : undefined,
        LocalSecondaryIndexes: output.LocalSecondaryIndexes != null
            ? de_SecondaryIndexesCapacityMap(output.LocalSecondaryIndexes, context)
            : undefined,
        ReadCapacityUnits: (0, smithy_client_1.limitedParseDouble)(output.ReadCapacityUnits),
        Table: output.Table != null ? de_Capacity(output.Table, context) : undefined,
        TableName: (0, smithy_client_1.expectString)(output.TableName),
        WriteCapacityUnits: (0, smithy_client_1.limitedParseDouble)(output.WriteCapacityUnits),
    };
};
const de_ConsumedCapacityMultiple = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ConsumedCapacity(entry, context);
    });
    return retVal;
};
const de_ContinuousBackupsDescription = (output, context) => {
    return {
        ContinuousBackupsStatus: (0, smithy_client_1.expectString)(output.ContinuousBackupsStatus),
        PointInTimeRecoveryDescription: output.PointInTimeRecoveryDescription != null
            ? de_PointInTimeRecoveryDescription(output.PointInTimeRecoveryDescription, context)
            : undefined,
    };
};
const de_ContinuousBackupsUnavailableException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ContributorInsightsRuleList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const de_ContributorInsightsSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ContributorInsightsSummary(entry, context);
    });
    return retVal;
};
const de_ContributorInsightsSummary = (output, context) => {
    return {
        ContributorInsightsStatus: (0, smithy_client_1.expectString)(output.ContributorInsightsStatus),
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_CreateBackupOutput = (output, context) => {
    return {
        BackupDetails: output.BackupDetails != null ? de_BackupDetails(output.BackupDetails, context) : undefined,
    };
};
const de_CreateGlobalTableOutput = (output, context) => {
    return {
        GlobalTableDescription: output.GlobalTableDescription != null
            ? de_GlobalTableDescription(output.GlobalTableDescription, context)
            : undefined,
    };
};
const de_CreateTableOutput = (output, context) => {
    return {
        TableDescription: output.TableDescription != null ? de_TableDescription(output.TableDescription, context) : undefined,
    };
};
const de_CsvHeaderList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const de_CsvOptions = (output, context) => {
    return {
        Delimiter: (0, smithy_client_1.expectString)(output.Delimiter),
        HeaderList: output.HeaderList != null ? de_CsvHeaderList(output.HeaderList, context) : undefined,
    };
};
const de_DeleteBackupOutput = (output, context) => {
    return {
        BackupDescription: output.BackupDescription != null ? de_BackupDescription(output.BackupDescription, context) : undefined,
    };
};
const de_DeleteItemOutput = (output, context) => {
    return {
        Attributes: output.Attributes != null ? de_AttributeMap(output.Attributes, context) : undefined,
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacity(output.ConsumedCapacity, context) : undefined,
        ItemCollectionMetrics: output.ItemCollectionMetrics != null
            ? de_ItemCollectionMetrics(output.ItemCollectionMetrics, context)
            : undefined,
    };
};
const de_DeleteRequest = (output, context) => {
    return {
        Key: output.Key != null ? de_Key(output.Key, context) : undefined,
    };
};
const de_DeleteTableOutput = (output, context) => {
    return {
        TableDescription: output.TableDescription != null ? de_TableDescription(output.TableDescription, context) : undefined,
    };
};
const de_DescribeBackupOutput = (output, context) => {
    return {
        BackupDescription: output.BackupDescription != null ? de_BackupDescription(output.BackupDescription, context) : undefined,
    };
};
const de_DescribeContinuousBackupsOutput = (output, context) => {
    return {
        ContinuousBackupsDescription: output.ContinuousBackupsDescription != null
            ? de_ContinuousBackupsDescription(output.ContinuousBackupsDescription, context)
            : undefined,
    };
};
const de_DescribeContributorInsightsOutput = (output, context) => {
    return {
        ContributorInsightsRuleList: output.ContributorInsightsRuleList != null
            ? de_ContributorInsightsRuleList(output.ContributorInsightsRuleList, context)
            : undefined,
        ContributorInsightsStatus: (0, smithy_client_1.expectString)(output.ContributorInsightsStatus),
        FailureException: output.FailureException != null ? de_FailureException(output.FailureException, context) : undefined,
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        LastUpdateDateTime: output.LastUpdateDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdateDateTime)))
            : undefined,
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_DescribeEndpointsResponse = (output, context) => {
    return {
        Endpoints: output.Endpoints != null ? de_Endpoints(output.Endpoints, context) : undefined,
    };
};
const de_DescribeExportOutput = (output, context) => {
    return {
        ExportDescription: output.ExportDescription != null ? de_ExportDescription(output.ExportDescription, context) : undefined,
    };
};
const de_DescribeGlobalTableOutput = (output, context) => {
    return {
        GlobalTableDescription: output.GlobalTableDescription != null
            ? de_GlobalTableDescription(output.GlobalTableDescription, context)
            : undefined,
    };
};
const de_DescribeGlobalTableSettingsOutput = (output, context) => {
    return {
        GlobalTableName: (0, smithy_client_1.expectString)(output.GlobalTableName),
        ReplicaSettings: output.ReplicaSettings != null ? de_ReplicaSettingsDescriptionList(output.ReplicaSettings, context) : undefined,
    };
};
const de_DescribeImportOutput = (output, context) => {
    return {
        ImportTableDescription: output.ImportTableDescription != null
            ? de_ImportTableDescription(output.ImportTableDescription, context)
            : undefined,
    };
};
const de_DescribeKinesisStreamingDestinationOutput = (output, context) => {
    return {
        KinesisDataStreamDestinations: output.KinesisDataStreamDestinations != null
            ? de_KinesisDataStreamDestinations(output.KinesisDataStreamDestinations, context)
            : undefined,
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_DescribeLimitsOutput = (output, context) => {
    return {
        AccountMaxReadCapacityUnits: (0, smithy_client_1.expectLong)(output.AccountMaxReadCapacityUnits),
        AccountMaxWriteCapacityUnits: (0, smithy_client_1.expectLong)(output.AccountMaxWriteCapacityUnits),
        TableMaxReadCapacityUnits: (0, smithy_client_1.expectLong)(output.TableMaxReadCapacityUnits),
        TableMaxWriteCapacityUnits: (0, smithy_client_1.expectLong)(output.TableMaxWriteCapacityUnits),
    };
};
const de_DescribeTableOutput = (output, context) => {
    return {
        Table: output.Table != null ? de_TableDescription(output.Table, context) : undefined,
    };
};
const de_DescribeTableReplicaAutoScalingOutput = (output, context) => {
    return {
        TableAutoScalingDescription: output.TableAutoScalingDescription != null
            ? de_TableAutoScalingDescription(output.TableAutoScalingDescription, context)
            : undefined,
    };
};
const de_DescribeTimeToLiveOutput = (output, context) => {
    return {
        TimeToLiveDescription: output.TimeToLiveDescription != null
            ? de_TimeToLiveDescription(output.TimeToLiveDescription, context)
            : undefined,
    };
};
const de_DuplicateItemException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_Endpoint = (output, context) => {
    return {
        Address: (0, smithy_client_1.expectString)(output.Address),
        CachePeriodInMinutes: (0, smithy_client_1.expectLong)(output.CachePeriodInMinutes),
    };
};
const de_Endpoints = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Endpoint(entry, context);
    });
    return retVal;
};
const de_ExecuteStatementOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacity(output.ConsumedCapacity, context) : undefined,
        Items: output.Items != null ? de_ItemList(output.Items, context) : undefined,
        LastEvaluatedKey: output.LastEvaluatedKey != null ? de_Key(output.LastEvaluatedKey, context) : undefined,
        NextToken: (0, smithy_client_1.expectString)(output.NextToken),
    };
};
const de_ExecuteTransactionOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacityMultiple(output.ConsumedCapacity, context) : undefined,
        Responses: output.Responses != null ? de_ItemResponseList(output.Responses, context) : undefined,
    };
};
const de_ExportConflictException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ExportDescription = (output, context) => {
    return {
        BilledSizeBytes: (0, smithy_client_1.expectLong)(output.BilledSizeBytes),
        ClientToken: (0, smithy_client_1.expectString)(output.ClientToken),
        EndTime: output.EndTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.EndTime))) : undefined,
        ExportArn: (0, smithy_client_1.expectString)(output.ExportArn),
        ExportFormat: (0, smithy_client_1.expectString)(output.ExportFormat),
        ExportManifest: (0, smithy_client_1.expectString)(output.ExportManifest),
        ExportStatus: (0, smithy_client_1.expectString)(output.ExportStatus),
        ExportTime: output.ExportTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.ExportTime))) : undefined,
        FailureCode: (0, smithy_client_1.expectString)(output.FailureCode),
        FailureMessage: (0, smithy_client_1.expectString)(output.FailureMessage),
        ItemCount: (0, smithy_client_1.expectLong)(output.ItemCount),
        S3Bucket: (0, smithy_client_1.expectString)(output.S3Bucket),
        S3BucketOwner: (0, smithy_client_1.expectString)(output.S3BucketOwner),
        S3Prefix: (0, smithy_client_1.expectString)(output.S3Prefix),
        S3SseAlgorithm: (0, smithy_client_1.expectString)(output.S3SseAlgorithm),
        S3SseKmsKeyId: (0, smithy_client_1.expectString)(output.S3SseKmsKeyId),
        StartTime: output.StartTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.StartTime))) : undefined,
        TableArn: (0, smithy_client_1.expectString)(output.TableArn),
        TableId: (0, smithy_client_1.expectString)(output.TableId),
    };
};
const de_ExportNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ExportSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ExportSummary(entry, context);
    });
    return retVal;
};
const de_ExportSummary = (output, context) => {
    return {
        ExportArn: (0, smithy_client_1.expectString)(output.ExportArn),
        ExportStatus: (0, smithy_client_1.expectString)(output.ExportStatus),
    };
};
const de_ExportTableToPointInTimeOutput = (output, context) => {
    return {
        ExportDescription: output.ExportDescription != null ? de_ExportDescription(output.ExportDescription, context) : undefined,
    };
};
const de_ExpressionAttributeNameMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const de_FailureException = (output, context) => {
    return {
        ExceptionDescription: (0, smithy_client_1.expectString)(output.ExceptionDescription),
        ExceptionName: (0, smithy_client_1.expectString)(output.ExceptionName),
    };
};
const de_GetItemOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacity(output.ConsumedCapacity, context) : undefined,
        Item: output.Item != null ? de_AttributeMap(output.Item, context) : undefined,
    };
};
const de_GlobalSecondaryIndex = (output, context) => {
    return {
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        Projection: output.Projection != null ? de_Projection(output.Projection, context) : undefined,
        ProvisionedThroughput: output.ProvisionedThroughput != null
            ? de_ProvisionedThroughput(output.ProvisionedThroughput, context)
            : undefined,
    };
};
const de_GlobalSecondaryIndexDescription = (output, context) => {
    return {
        Backfilling: (0, smithy_client_1.expectBoolean)(output.Backfilling),
        IndexArn: (0, smithy_client_1.expectString)(output.IndexArn),
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        IndexSizeBytes: (0, smithy_client_1.expectLong)(output.IndexSizeBytes),
        IndexStatus: (0, smithy_client_1.expectString)(output.IndexStatus),
        ItemCount: (0, smithy_client_1.expectLong)(output.ItemCount),
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        Projection: output.Projection != null ? de_Projection(output.Projection, context) : undefined,
        ProvisionedThroughput: output.ProvisionedThroughput != null
            ? de_ProvisionedThroughputDescription(output.ProvisionedThroughput, context)
            : undefined,
    };
};
const de_GlobalSecondaryIndexDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_GlobalSecondaryIndexDescription(entry, context);
    });
    return retVal;
};
const de_GlobalSecondaryIndexes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_GlobalSecondaryIndexInfo(entry, context);
    });
    return retVal;
};
const de_GlobalSecondaryIndexInfo = (output, context) => {
    return {
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        Projection: output.Projection != null ? de_Projection(output.Projection, context) : undefined,
        ProvisionedThroughput: output.ProvisionedThroughput != null
            ? de_ProvisionedThroughput(output.ProvisionedThroughput, context)
            : undefined,
    };
};
const de_GlobalSecondaryIndexList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_GlobalSecondaryIndex(entry, context);
    });
    return retVal;
};
const de_GlobalTable = (output, context) => {
    return {
        GlobalTableName: (0, smithy_client_1.expectString)(output.GlobalTableName),
        ReplicationGroup: output.ReplicationGroup != null ? de_ReplicaList(output.ReplicationGroup, context) : undefined,
    };
};
const de_GlobalTableAlreadyExistsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_GlobalTableDescription = (output, context) => {
    return {
        CreationDateTime: output.CreationDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreationDateTime)))
            : undefined,
        GlobalTableArn: (0, smithy_client_1.expectString)(output.GlobalTableArn),
        GlobalTableName: (0, smithy_client_1.expectString)(output.GlobalTableName),
        GlobalTableStatus: (0, smithy_client_1.expectString)(output.GlobalTableStatus),
        ReplicationGroup: output.ReplicationGroup != null ? de_ReplicaDescriptionList(output.ReplicationGroup, context) : undefined,
    };
};
const de_GlobalTableList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_GlobalTable(entry, context);
    });
    return retVal;
};
const de_GlobalTableNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_IdempotentParameterMismatchException = (output, context) => {
    return {
        Message: (0, smithy_client_1.expectString)(output.Message),
    };
};
const de_ImportConflictException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ImportNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ImportSummary = (output, context) => {
    return {
        CloudWatchLogGroupArn: (0, smithy_client_1.expectString)(output.CloudWatchLogGroupArn),
        EndTime: output.EndTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.EndTime))) : undefined,
        ImportArn: (0, smithy_client_1.expectString)(output.ImportArn),
        ImportStatus: (0, smithy_client_1.expectString)(output.ImportStatus),
        InputFormat: (0, smithy_client_1.expectString)(output.InputFormat),
        S3BucketSource: output.S3BucketSource != null ? de_S3BucketSource(output.S3BucketSource, context) : undefined,
        StartTime: output.StartTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.StartTime))) : undefined,
        TableArn: (0, smithy_client_1.expectString)(output.TableArn),
    };
};
const de_ImportSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ImportSummary(entry, context);
    });
    return retVal;
};
const de_ImportTableDescription = (output, context) => {
    return {
        ClientToken: (0, smithy_client_1.expectString)(output.ClientToken),
        CloudWatchLogGroupArn: (0, smithy_client_1.expectString)(output.CloudWatchLogGroupArn),
        EndTime: output.EndTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.EndTime))) : undefined,
        ErrorCount: (0, smithy_client_1.expectLong)(output.ErrorCount),
        FailureCode: (0, smithy_client_1.expectString)(output.FailureCode),
        FailureMessage: (0, smithy_client_1.expectString)(output.FailureMessage),
        ImportArn: (0, smithy_client_1.expectString)(output.ImportArn),
        ImportStatus: (0, smithy_client_1.expectString)(output.ImportStatus),
        ImportedItemCount: (0, smithy_client_1.expectLong)(output.ImportedItemCount),
        InputCompressionType: (0, smithy_client_1.expectString)(output.InputCompressionType),
        InputFormat: (0, smithy_client_1.expectString)(output.InputFormat),
        InputFormatOptions: output.InputFormatOptions != null ? de_InputFormatOptions(output.InputFormatOptions, context) : undefined,
        ProcessedItemCount: (0, smithy_client_1.expectLong)(output.ProcessedItemCount),
        ProcessedSizeBytes: (0, smithy_client_1.expectLong)(output.ProcessedSizeBytes),
        S3BucketSource: output.S3BucketSource != null ? de_S3BucketSource(output.S3BucketSource, context) : undefined,
        StartTime: output.StartTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.StartTime))) : undefined,
        TableArn: (0, smithy_client_1.expectString)(output.TableArn),
        TableCreationParameters: output.TableCreationParameters != null
            ? de_TableCreationParameters(output.TableCreationParameters, context)
            : undefined,
        TableId: (0, smithy_client_1.expectString)(output.TableId),
    };
};
const de_ImportTableOutput = (output, context) => {
    return {
        ImportTableDescription: output.ImportTableDescription != null
            ? de_ImportTableDescription(output.ImportTableDescription, context)
            : undefined,
    };
};
const de_IndexNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_InputFormatOptions = (output, context) => {
    return {
        Csv: output.Csv != null ? de_CsvOptions(output.Csv, context) : undefined,
    };
};
const de_InternalServerError = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_InvalidEndpointException = (output, context) => {
    return {
        Message: (0, smithy_client_1.expectString)(output.Message),
    };
};
const de_InvalidExportTimeException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_InvalidRestoreTimeException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ItemCollectionKeyAttributeMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0, smithy_client_1.expectUnion)(value), context);
        return acc;
    }, {});
};
const de_ItemCollectionMetrics = (output, context) => {
    return {
        ItemCollectionKey: output.ItemCollectionKey != null
            ? de_ItemCollectionKeyAttributeMap(output.ItemCollectionKey, context)
            : undefined,
        SizeEstimateRangeGB: output.SizeEstimateRangeGB != null
            ? de_ItemCollectionSizeEstimateRange(output.SizeEstimateRangeGB, context)
            : undefined,
    };
};
const de_ItemCollectionMetricsMultiple = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ItemCollectionMetrics(entry, context);
    });
    return retVal;
};
const de_ItemCollectionMetricsPerTable = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ItemCollectionMetricsMultiple(value, context);
        return acc;
    }, {});
};
const de_ItemCollectionSizeEstimateRange = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.limitedParseDouble)(entry);
    });
    return retVal;
};
const de_ItemCollectionSizeLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AttributeMap(entry, context);
    });
    return retVal;
};
const de_ItemResponse = (output, context) => {
    return {
        Item: output.Item != null ? de_AttributeMap(output.Item, context) : undefined,
    };
};
const de_ItemResponseList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ItemResponse(entry, context);
    });
    return retVal;
};
const de_Key = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0, smithy_client_1.expectUnion)(value), context);
        return acc;
    }, {});
};
const de_KeyList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Key(entry, context);
    });
    return retVal;
};
const de_KeysAndAttributes = (output, context) => {
    return {
        AttributesToGet: output.AttributesToGet != null ? de_AttributeNameList(output.AttributesToGet, context) : undefined,
        ConsistentRead: (0, smithy_client_1.expectBoolean)(output.ConsistentRead),
        ExpressionAttributeNames: output.ExpressionAttributeNames != null
            ? de_ExpressionAttributeNameMap(output.ExpressionAttributeNames, context)
            : undefined,
        Keys: output.Keys != null ? de_KeyList(output.Keys, context) : undefined,
        ProjectionExpression: (0, smithy_client_1.expectString)(output.ProjectionExpression),
    };
};
const de_KeySchema = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_KeySchemaElement(entry, context);
    });
    return retVal;
};
const de_KeySchemaElement = (output, context) => {
    return {
        AttributeName: (0, smithy_client_1.expectString)(output.AttributeName),
        KeyType: (0, smithy_client_1.expectString)(output.KeyType),
    };
};
const de_KinesisDataStreamDestination = (output, context) => {
    return {
        DestinationStatus: (0, smithy_client_1.expectString)(output.DestinationStatus),
        DestinationStatusDescription: (0, smithy_client_1.expectString)(output.DestinationStatusDescription),
        StreamArn: (0, smithy_client_1.expectString)(output.StreamArn),
    };
};
const de_KinesisDataStreamDestinations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_KinesisDataStreamDestination(entry, context);
    });
    return retVal;
};
const de_KinesisStreamingDestinationOutput = (output, context) => {
    return {
        DestinationStatus: (0, smithy_client_1.expectString)(output.DestinationStatus),
        StreamArn: (0, smithy_client_1.expectString)(output.StreamArn),
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_LimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ListAttributeValue = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AttributeValue((0, smithy_client_1.expectUnion)(entry), context);
    });
    return retVal;
};
const de_ListBackupsOutput = (output, context) => {
    return {
        BackupSummaries: output.BackupSummaries != null ? de_BackupSummaries(output.BackupSummaries, context) : undefined,
        LastEvaluatedBackupArn: (0, smithy_client_1.expectString)(output.LastEvaluatedBackupArn),
    };
};
const de_ListContributorInsightsOutput = (output, context) => {
    return {
        ContributorInsightsSummaries: output.ContributorInsightsSummaries != null
            ? de_ContributorInsightsSummaries(output.ContributorInsightsSummaries, context)
            : undefined,
        NextToken: (0, smithy_client_1.expectString)(output.NextToken),
    };
};
const de_ListExportsOutput = (output, context) => {
    return {
        ExportSummaries: output.ExportSummaries != null ? de_ExportSummaries(output.ExportSummaries, context) : undefined,
        NextToken: (0, smithy_client_1.expectString)(output.NextToken),
    };
};
const de_ListGlobalTablesOutput = (output, context) => {
    return {
        GlobalTables: output.GlobalTables != null ? de_GlobalTableList(output.GlobalTables, context) : undefined,
        LastEvaluatedGlobalTableName: (0, smithy_client_1.expectString)(output.LastEvaluatedGlobalTableName),
    };
};
const de_ListImportsOutput = (output, context) => {
    return {
        ImportSummaryList: output.ImportSummaryList != null ? de_ImportSummaryList(output.ImportSummaryList, context) : undefined,
        NextToken: (0, smithy_client_1.expectString)(output.NextToken),
    };
};
const de_ListTablesOutput = (output, context) => {
    return {
        LastEvaluatedTableName: (0, smithy_client_1.expectString)(output.LastEvaluatedTableName),
        TableNames: output.TableNames != null ? de_TableNameList(output.TableNames, context) : undefined,
    };
};
const de_ListTagsOfResourceOutput = (output, context) => {
    return {
        NextToken: (0, smithy_client_1.expectString)(output.NextToken),
        Tags: output.Tags != null ? de_TagList(output.Tags, context) : undefined,
    };
};
const de_LocalSecondaryIndexDescription = (output, context) => {
    return {
        IndexArn: (0, smithy_client_1.expectString)(output.IndexArn),
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        IndexSizeBytes: (0, smithy_client_1.expectLong)(output.IndexSizeBytes),
        ItemCount: (0, smithy_client_1.expectLong)(output.ItemCount),
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        Projection: output.Projection != null ? de_Projection(output.Projection, context) : undefined,
    };
};
const de_LocalSecondaryIndexDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_LocalSecondaryIndexDescription(entry, context);
    });
    return retVal;
};
const de_LocalSecondaryIndexes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_LocalSecondaryIndexInfo(entry, context);
    });
    return retVal;
};
const de_LocalSecondaryIndexInfo = (output, context) => {
    return {
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        Projection: output.Projection != null ? de_Projection(output.Projection, context) : undefined,
    };
};
const de_MapAttributeValue = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0, smithy_client_1.expectUnion)(value), context);
        return acc;
    }, {});
};
const de_NonKeyAttributeNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const de_NumberSetAttributeValue = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const de_PartiQLBatchResponse = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_BatchStatementResponse(entry, context);
    });
    return retVal;
};
const de_PointInTimeRecoveryDescription = (output, context) => {
    return {
        EarliestRestorableDateTime: output.EarliestRestorableDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.EarliestRestorableDateTime)))
            : undefined,
        LatestRestorableDateTime: output.LatestRestorableDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LatestRestorableDateTime)))
            : undefined,
        PointInTimeRecoveryStatus: (0, smithy_client_1.expectString)(output.PointInTimeRecoveryStatus),
    };
};
const de_PointInTimeRecoveryUnavailableException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_Projection = (output, context) => {
    return {
        NonKeyAttributes: output.NonKeyAttributes != null ? de_NonKeyAttributeNameList(output.NonKeyAttributes, context) : undefined,
        ProjectionType: (0, smithy_client_1.expectString)(output.ProjectionType),
    };
};
const de_ProvisionedThroughput = (output, context) => {
    return {
        ReadCapacityUnits: (0, smithy_client_1.expectLong)(output.ReadCapacityUnits),
        WriteCapacityUnits: (0, smithy_client_1.expectLong)(output.WriteCapacityUnits),
    };
};
const de_ProvisionedThroughputDescription = (output, context) => {
    return {
        LastDecreaseDateTime: output.LastDecreaseDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastDecreaseDateTime)))
            : undefined,
        LastIncreaseDateTime: output.LastIncreaseDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastIncreaseDateTime)))
            : undefined,
        NumberOfDecreasesToday: (0, smithy_client_1.expectLong)(output.NumberOfDecreasesToday),
        ReadCapacityUnits: (0, smithy_client_1.expectLong)(output.ReadCapacityUnits),
        WriteCapacityUnits: (0, smithy_client_1.expectLong)(output.WriteCapacityUnits),
    };
};
const de_ProvisionedThroughputExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ProvisionedThroughputOverride = (output, context) => {
    return {
        ReadCapacityUnits: (0, smithy_client_1.expectLong)(output.ReadCapacityUnits),
    };
};
const de_PutItemInputAttributeMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0, smithy_client_1.expectUnion)(value), context);
        return acc;
    }, {});
};
const de_PutItemOutput = (output, context) => {
    return {
        Attributes: output.Attributes != null ? de_AttributeMap(output.Attributes, context) : undefined,
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacity(output.ConsumedCapacity, context) : undefined,
        ItemCollectionMetrics: output.ItemCollectionMetrics != null
            ? de_ItemCollectionMetrics(output.ItemCollectionMetrics, context)
            : undefined,
    };
};
const de_PutRequest = (output, context) => {
    return {
        Item: output.Item != null ? de_PutItemInputAttributeMap(output.Item, context) : undefined,
    };
};
const de_QueryOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacity(output.ConsumedCapacity, context) : undefined,
        Count: (0, smithy_client_1.expectInt32)(output.Count),
        Items: output.Items != null ? de_ItemList(output.Items, context) : undefined,
        LastEvaluatedKey: output.LastEvaluatedKey != null ? de_Key(output.LastEvaluatedKey, context) : undefined,
        ScannedCount: (0, smithy_client_1.expectInt32)(output.ScannedCount),
    };
};
const de_Replica = (output, context) => {
    return {
        RegionName: (0, smithy_client_1.expectString)(output.RegionName),
    };
};
const de_ReplicaAlreadyExistsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ReplicaAutoScalingDescription = (output, context) => {
    return {
        GlobalSecondaryIndexes: output.GlobalSecondaryIndexes != null
            ? de_ReplicaGlobalSecondaryIndexAutoScalingDescriptionList(output.GlobalSecondaryIndexes, context)
            : undefined,
        RegionName: (0, smithy_client_1.expectString)(output.RegionName),
        ReplicaProvisionedReadCapacityAutoScalingSettings: output.ReplicaProvisionedReadCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ReplicaProvisionedReadCapacityAutoScalingSettings, context)
            : undefined,
        ReplicaProvisionedWriteCapacityAutoScalingSettings: output.ReplicaProvisionedWriteCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ReplicaProvisionedWriteCapacityAutoScalingSettings, context)
            : undefined,
        ReplicaStatus: (0, smithy_client_1.expectString)(output.ReplicaStatus),
    };
};
const de_ReplicaAutoScalingDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ReplicaAutoScalingDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaDescription = (output, context) => {
    return {
        GlobalSecondaryIndexes: output.GlobalSecondaryIndexes != null
            ? de_ReplicaGlobalSecondaryIndexDescriptionList(output.GlobalSecondaryIndexes, context)
            : undefined,
        KMSMasterKeyId: (0, smithy_client_1.expectString)(output.KMSMasterKeyId),
        ProvisionedThroughputOverride: output.ProvisionedThroughputOverride != null
            ? de_ProvisionedThroughputOverride(output.ProvisionedThroughputOverride, context)
            : undefined,
        RegionName: (0, smithy_client_1.expectString)(output.RegionName),
        ReplicaInaccessibleDateTime: output.ReplicaInaccessibleDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.ReplicaInaccessibleDateTime)))
            : undefined,
        ReplicaStatus: (0, smithy_client_1.expectString)(output.ReplicaStatus),
        ReplicaStatusDescription: (0, smithy_client_1.expectString)(output.ReplicaStatusDescription),
        ReplicaStatusPercentProgress: (0, smithy_client_1.expectString)(output.ReplicaStatusPercentProgress),
        ReplicaTableClassSummary: output.ReplicaTableClassSummary != null
            ? de_TableClassSummary(output.ReplicaTableClassSummary, context)
            : undefined,
    };
};
const de_ReplicaDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ReplicaDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaGlobalSecondaryIndexAutoScalingDescription = (output, context) => {
    return {
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        IndexStatus: (0, smithy_client_1.expectString)(output.IndexStatus),
        ProvisionedReadCapacityAutoScalingSettings: output.ProvisionedReadCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ProvisionedReadCapacityAutoScalingSettings, context)
            : undefined,
        ProvisionedWriteCapacityAutoScalingSettings: output.ProvisionedWriteCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ProvisionedWriteCapacityAutoScalingSettings, context)
            : undefined,
    };
};
const de_ReplicaGlobalSecondaryIndexAutoScalingDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ReplicaGlobalSecondaryIndexAutoScalingDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaGlobalSecondaryIndexDescription = (output, context) => {
    return {
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        ProvisionedThroughputOverride: output.ProvisionedThroughputOverride != null
            ? de_ProvisionedThroughputOverride(output.ProvisionedThroughputOverride, context)
            : undefined,
    };
};
const de_ReplicaGlobalSecondaryIndexDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ReplicaGlobalSecondaryIndexDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaGlobalSecondaryIndexSettingsDescription = (output, context) => {
    return {
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        IndexStatus: (0, smithy_client_1.expectString)(output.IndexStatus),
        ProvisionedReadCapacityAutoScalingSettings: output.ProvisionedReadCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ProvisionedReadCapacityAutoScalingSettings, context)
            : undefined,
        ProvisionedReadCapacityUnits: (0, smithy_client_1.expectLong)(output.ProvisionedReadCapacityUnits),
        ProvisionedWriteCapacityAutoScalingSettings: output.ProvisionedWriteCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ProvisionedWriteCapacityAutoScalingSettings, context)
            : undefined,
        ProvisionedWriteCapacityUnits: (0, smithy_client_1.expectLong)(output.ProvisionedWriteCapacityUnits),
    };
};
const de_ReplicaGlobalSecondaryIndexSettingsDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ReplicaGlobalSecondaryIndexSettingsDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Replica(entry, context);
    });
    return retVal;
};
const de_ReplicaNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ReplicaSettingsDescription = (output, context) => {
    return {
        RegionName: (0, smithy_client_1.expectString)(output.RegionName),
        ReplicaBillingModeSummary: output.ReplicaBillingModeSummary != null
            ? de_BillingModeSummary(output.ReplicaBillingModeSummary, context)
            : undefined,
        ReplicaGlobalSecondaryIndexSettings: output.ReplicaGlobalSecondaryIndexSettings != null
            ? de_ReplicaGlobalSecondaryIndexSettingsDescriptionList(output.ReplicaGlobalSecondaryIndexSettings, context)
            : undefined,
        ReplicaProvisionedReadCapacityAutoScalingSettings: output.ReplicaProvisionedReadCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ReplicaProvisionedReadCapacityAutoScalingSettings, context)
            : undefined,
        ReplicaProvisionedReadCapacityUnits: (0, smithy_client_1.expectLong)(output.ReplicaProvisionedReadCapacityUnits),
        ReplicaProvisionedWriteCapacityAutoScalingSettings: output.ReplicaProvisionedWriteCapacityAutoScalingSettings != null
            ? de_AutoScalingSettingsDescription(output.ReplicaProvisionedWriteCapacityAutoScalingSettings, context)
            : undefined,
        ReplicaProvisionedWriteCapacityUnits: (0, smithy_client_1.expectLong)(output.ReplicaProvisionedWriteCapacityUnits),
        ReplicaStatus: (0, smithy_client_1.expectString)(output.ReplicaStatus),
        ReplicaTableClassSummary: output.ReplicaTableClassSummary != null
            ? de_TableClassSummary(output.ReplicaTableClassSummary, context)
            : undefined,
    };
};
const de_ReplicaSettingsDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ReplicaSettingsDescription(entry, context);
    });
    return retVal;
};
const de_RequestLimitExceeded = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ResourceInUseException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_ResourceNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_RestoreSummary = (output, context) => {
    return {
        RestoreDateTime: output.RestoreDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.RestoreDateTime)))
            : undefined,
        RestoreInProgress: (0, smithy_client_1.expectBoolean)(output.RestoreInProgress),
        SourceBackupArn: (0, smithy_client_1.expectString)(output.SourceBackupArn),
        SourceTableArn: (0, smithy_client_1.expectString)(output.SourceTableArn),
    };
};
const de_RestoreTableFromBackupOutput = (output, context) => {
    return {
        TableDescription: output.TableDescription != null ? de_TableDescription(output.TableDescription, context) : undefined,
    };
};
const de_RestoreTableToPointInTimeOutput = (output, context) => {
    return {
        TableDescription: output.TableDescription != null ? de_TableDescription(output.TableDescription, context) : undefined,
    };
};
const de_S3BucketSource = (output, context) => {
    return {
        S3Bucket: (0, smithy_client_1.expectString)(output.S3Bucket),
        S3BucketOwner: (0, smithy_client_1.expectString)(output.S3BucketOwner),
        S3KeyPrefix: (0, smithy_client_1.expectString)(output.S3KeyPrefix),
    };
};
const de_ScanOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacity(output.ConsumedCapacity, context) : undefined,
        Count: (0, smithy_client_1.expectInt32)(output.Count),
        Items: output.Items != null ? de_ItemList(output.Items, context) : undefined,
        LastEvaluatedKey: output.LastEvaluatedKey != null ? de_Key(output.LastEvaluatedKey, context) : undefined,
        ScannedCount: (0, smithy_client_1.expectInt32)(output.ScannedCount),
    };
};
const de_SecondaryIndexesCapacityMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_Capacity(value, context);
        return acc;
    }, {});
};
const de_SourceTableDetails = (output, context) => {
    return {
        BillingMode: (0, smithy_client_1.expectString)(output.BillingMode),
        ItemCount: (0, smithy_client_1.expectLong)(output.ItemCount),
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        ProvisionedThroughput: output.ProvisionedThroughput != null
            ? de_ProvisionedThroughput(output.ProvisionedThroughput, context)
            : undefined,
        TableArn: (0, smithy_client_1.expectString)(output.TableArn),
        TableCreationDateTime: output.TableCreationDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.TableCreationDateTime)))
            : undefined,
        TableId: (0, smithy_client_1.expectString)(output.TableId),
        TableName: (0, smithy_client_1.expectString)(output.TableName),
        TableSizeBytes: (0, smithy_client_1.expectLong)(output.TableSizeBytes),
    };
};
const de_SourceTableFeatureDetails = (output, context) => {
    return {
        GlobalSecondaryIndexes: output.GlobalSecondaryIndexes != null
            ? de_GlobalSecondaryIndexes(output.GlobalSecondaryIndexes, context)
            : undefined,
        LocalSecondaryIndexes: output.LocalSecondaryIndexes != null
            ? de_LocalSecondaryIndexes(output.LocalSecondaryIndexes, context)
            : undefined,
        SSEDescription: output.SSEDescription != null ? de_SSEDescription(output.SSEDescription, context) : undefined,
        StreamDescription: output.StreamDescription != null ? de_StreamSpecification(output.StreamDescription, context) : undefined,
        TimeToLiveDescription: output.TimeToLiveDescription != null
            ? de_TimeToLiveDescription(output.TimeToLiveDescription, context)
            : undefined,
    };
};
const de_SSEDescription = (output, context) => {
    return {
        InaccessibleEncryptionDateTime: output.InaccessibleEncryptionDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.InaccessibleEncryptionDateTime)))
            : undefined,
        KMSMasterKeyArn: (0, smithy_client_1.expectString)(output.KMSMasterKeyArn),
        SSEType: (0, smithy_client_1.expectString)(output.SSEType),
        Status: (0, smithy_client_1.expectString)(output.Status),
    };
};
const de_SSESpecification = (output, context) => {
    return {
        Enabled: (0, smithy_client_1.expectBoolean)(output.Enabled),
        KMSMasterKeyId: (0, smithy_client_1.expectString)(output.KMSMasterKeyId),
        SSEType: (0, smithy_client_1.expectString)(output.SSEType),
    };
};
const de_StreamSpecification = (output, context) => {
    return {
        StreamEnabled: (0, smithy_client_1.expectBoolean)(output.StreamEnabled),
        StreamViewType: (0, smithy_client_1.expectString)(output.StreamViewType),
    };
};
const de_StringSetAttributeValue = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const de_TableAlreadyExistsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_TableAutoScalingDescription = (output, context) => {
    return {
        Replicas: output.Replicas != null ? de_ReplicaAutoScalingDescriptionList(output.Replicas, context) : undefined,
        TableName: (0, smithy_client_1.expectString)(output.TableName),
        TableStatus: (0, smithy_client_1.expectString)(output.TableStatus),
    };
};
const de_TableClassSummary = (output, context) => {
    return {
        LastUpdateDateTime: output.LastUpdateDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdateDateTime)))
            : undefined,
        TableClass: (0, smithy_client_1.expectString)(output.TableClass),
    };
};
const de_TableCreationParameters = (output, context) => {
    return {
        AttributeDefinitions: output.AttributeDefinitions != null ? de_AttributeDefinitions(output.AttributeDefinitions, context) : undefined,
        BillingMode: (0, smithy_client_1.expectString)(output.BillingMode),
        GlobalSecondaryIndexes: output.GlobalSecondaryIndexes != null
            ? de_GlobalSecondaryIndexList(output.GlobalSecondaryIndexes, context)
            : undefined,
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        ProvisionedThroughput: output.ProvisionedThroughput != null
            ? de_ProvisionedThroughput(output.ProvisionedThroughput, context)
            : undefined,
        SSESpecification: output.SSESpecification != null ? de_SSESpecification(output.SSESpecification, context) : undefined,
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_TableDescription = (output, context) => {
    return {
        ArchivalSummary: output.ArchivalSummary != null ? de_ArchivalSummary(output.ArchivalSummary, context) : undefined,
        AttributeDefinitions: output.AttributeDefinitions != null ? de_AttributeDefinitions(output.AttributeDefinitions, context) : undefined,
        BillingModeSummary: output.BillingModeSummary != null ? de_BillingModeSummary(output.BillingModeSummary, context) : undefined,
        CreationDateTime: output.CreationDateTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreationDateTime)))
            : undefined,
        DeletionProtectionEnabled: (0, smithy_client_1.expectBoolean)(output.DeletionProtectionEnabled),
        GlobalSecondaryIndexes: output.GlobalSecondaryIndexes != null
            ? de_GlobalSecondaryIndexDescriptionList(output.GlobalSecondaryIndexes, context)
            : undefined,
        GlobalTableVersion: (0, smithy_client_1.expectString)(output.GlobalTableVersion),
        ItemCount: (0, smithy_client_1.expectLong)(output.ItemCount),
        KeySchema: output.KeySchema != null ? de_KeySchema(output.KeySchema, context) : undefined,
        LatestStreamArn: (0, smithy_client_1.expectString)(output.LatestStreamArn),
        LatestStreamLabel: (0, smithy_client_1.expectString)(output.LatestStreamLabel),
        LocalSecondaryIndexes: output.LocalSecondaryIndexes != null
            ? de_LocalSecondaryIndexDescriptionList(output.LocalSecondaryIndexes, context)
            : undefined,
        ProvisionedThroughput: output.ProvisionedThroughput != null
            ? de_ProvisionedThroughputDescription(output.ProvisionedThroughput, context)
            : undefined,
        Replicas: output.Replicas != null ? de_ReplicaDescriptionList(output.Replicas, context) : undefined,
        RestoreSummary: output.RestoreSummary != null ? de_RestoreSummary(output.RestoreSummary, context) : undefined,
        SSEDescription: output.SSEDescription != null ? de_SSEDescription(output.SSEDescription, context) : undefined,
        StreamSpecification: output.StreamSpecification != null ? de_StreamSpecification(output.StreamSpecification, context) : undefined,
        TableArn: (0, smithy_client_1.expectString)(output.TableArn),
        TableClassSummary: output.TableClassSummary != null ? de_TableClassSummary(output.TableClassSummary, context) : undefined,
        TableId: (0, smithy_client_1.expectString)(output.TableId),
        TableName: (0, smithy_client_1.expectString)(output.TableName),
        TableSizeBytes: (0, smithy_client_1.expectLong)(output.TableSizeBytes),
        TableStatus: (0, smithy_client_1.expectString)(output.TableStatus),
    };
};
const de_TableInUseException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_TableNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const de_TableNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_Tag = (output, context) => {
    return {
        Key: (0, smithy_client_1.expectString)(output.Key),
        Value: (0, smithy_client_1.expectString)(output.Value),
    };
};
const de_TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Tag(entry, context);
    });
    return retVal;
};
const de_TimeToLiveDescription = (output, context) => {
    return {
        AttributeName: (0, smithy_client_1.expectString)(output.AttributeName),
        TimeToLiveStatus: (0, smithy_client_1.expectString)(output.TimeToLiveStatus),
    };
};
const de_TimeToLiveSpecification = (output, context) => {
    return {
        AttributeName: (0, smithy_client_1.expectString)(output.AttributeName),
        Enabled: (0, smithy_client_1.expectBoolean)(output.Enabled),
    };
};
const de_TransactGetItemsOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacityMultiple(output.ConsumedCapacity, context) : undefined,
        Responses: output.Responses != null ? de_ItemResponseList(output.Responses, context) : undefined,
    };
};
const de_TransactionCanceledException = (output, context) => {
    return {
        CancellationReasons: output.CancellationReasons != null ? de_CancellationReasonList(output.CancellationReasons, context) : undefined,
        Message: (0, smithy_client_1.expectString)(output.Message),
    };
};
const de_TransactionConflictException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const de_TransactionInProgressException = (output, context) => {
    return {
        Message: (0, smithy_client_1.expectString)(output.Message),
    };
};
const de_TransactWriteItemsOutput = (output, context) => {
    return {
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacityMultiple(output.ConsumedCapacity, context) : undefined,
        ItemCollectionMetrics: output.ItemCollectionMetrics != null
            ? de_ItemCollectionMetricsPerTable(output.ItemCollectionMetrics, context)
            : undefined,
    };
};
const de_UpdateContinuousBackupsOutput = (output, context) => {
    return {
        ContinuousBackupsDescription: output.ContinuousBackupsDescription != null
            ? de_ContinuousBackupsDescription(output.ContinuousBackupsDescription, context)
            : undefined,
    };
};
const de_UpdateContributorInsightsOutput = (output, context) => {
    return {
        ContributorInsightsStatus: (0, smithy_client_1.expectString)(output.ContributorInsightsStatus),
        IndexName: (0, smithy_client_1.expectString)(output.IndexName),
        TableName: (0, smithy_client_1.expectString)(output.TableName),
    };
};
const de_UpdateGlobalTableOutput = (output, context) => {
    return {
        GlobalTableDescription: output.GlobalTableDescription != null
            ? de_GlobalTableDescription(output.GlobalTableDescription, context)
            : undefined,
    };
};
const de_UpdateGlobalTableSettingsOutput = (output, context) => {
    return {
        GlobalTableName: (0, smithy_client_1.expectString)(output.GlobalTableName),
        ReplicaSettings: output.ReplicaSettings != null ? de_ReplicaSettingsDescriptionList(output.ReplicaSettings, context) : undefined,
    };
};
const de_UpdateItemOutput = (output, context) => {
    return {
        Attributes: output.Attributes != null ? de_AttributeMap(output.Attributes, context) : undefined,
        ConsumedCapacity: output.ConsumedCapacity != null ? de_ConsumedCapacity(output.ConsumedCapacity, context) : undefined,
        ItemCollectionMetrics: output.ItemCollectionMetrics != null
            ? de_ItemCollectionMetrics(output.ItemCollectionMetrics, context)
            : undefined,
    };
};
const de_UpdateTableOutput = (output, context) => {
    return {
        TableDescription: output.TableDescription != null ? de_TableDescription(output.TableDescription, context) : undefined,
    };
};
const de_UpdateTableReplicaAutoScalingOutput = (output, context) => {
    return {
        TableAutoScalingDescription: output.TableAutoScalingDescription != null
            ? de_TableAutoScalingDescription(output.TableAutoScalingDescription, context)
            : undefined,
    };
};
const de_UpdateTimeToLiveOutput = (output, context) => {
    return {
        TimeToLiveSpecification: output.TimeToLiveSpecification != null
            ? de_TimeToLiveSpecification(output.TimeToLiveSpecification, context)
            : undefined,
    };
};
const de_WriteRequest = (output, context) => {
    return {
        DeleteRequest: output.DeleteRequest != null ? de_DeleteRequest(output.DeleteRequest, context) : undefined,
        PutRequest: output.PutRequest != null ? de_PutRequest(output.PutRequest, context) : undefined,
    };
};
const de_WriteRequests = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_WriteRequest(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};

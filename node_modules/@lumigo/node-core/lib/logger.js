"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogger = exports.setLoggerPrefix = exports.setLogger = exports.LogStore = exports.LOG_LEVELS = void 0;
const utils_1 = require("./utils");
const WARN_CLIENT_PREFIX = 'Lumigo Warning';
let LOG_PREFIX = '#LUMIGO#';
const MAX_DUPLICATE_LOGS = 50;
exports.LOG_LEVELS = {
    INFO: 'INFO',
    WARNING: 'WARNING',
    FATAL: 'FATAL',
    DEBUG: 'DEBUG',
};
const removeCircleFromJson = () => {
    const cache = [];
    return (key, value) => {
        if (typeof value === 'object' && value !== null) {
            // Duplicate reference found, discard key
            if (cache.includes(value))
                return;
            // Store value in our collection
            cache.push(value);
        }
        return value;
    };
};
exports.LogStore = (() => {
    let logSet = new Set([]);
    let duplicateLogsCount = 0;
    const addLog = (type, message, object) => {
        const logObj = JSON.stringify({ type, message, object }, removeCircleFromJson());
        if (!logSet.has(logObj)) {
            logSet.add(logObj);
        }
        else {
            duplicateLogsCount++;
        }
        isEmergencyMode() && printLogs();
    };
    const printLogs = () => {
        logSet.forEach((logObj) => {
            const { message, obj } = JSON.parse(logObj);
            forceLog('FATAL', message, obj);
        });
        logSet.clear();
    };
    const isEmergencyMode = () => duplicateLogsCount >= MAX_DUPLICATE_LOGS;
    const clean = () => {
        logSet = new Set([]);
        duplicateLogsCount = 0;
    };
    return { addLog, clean };
})();
/**
  @deprecated
 */
function forceLog(levelname, message, obj) {
    const escapedMessage = JSON.stringify(message, null, 0);
    const logMsg = `${LOG_PREFIX} - ${levelname} - ${escapedMessage}`;
    if (obj) {
        let escapedObject = JSON.stringify(obj, null, 0);
        if (obj.stack && obj.message) {
            escapedObject = JSON.stringify({
                message: obj.message,
                stack: obj.stack,
            });
        }
        // eslint-disable-next-line
        console.log(logMsg, escapedObject);
    }
    else {
        // eslint-disable-next-line
        console.log(logMsg);
    }
}
const log = (levelname, message, obj) => {
    const storeLogsIsOn = (0, utils_1.isStoreLogs)();
    storeLogsIsOn && exports.LogStore.addLog(levelname, message, obj);
    if ((0, utils_1.isDebug)() && !storeLogsIsOn) {
        forceLog(levelname, message, obj);
    }
};
const invokeLog = (type) => (msg, obj = undefined) => log(type, msg, obj);
const info = invokeLog('INFO');
const warn = invokeLog('WARNING');
const fatal = invokeLog('FATAL');
const debug = invokeLog('DEBUG');
let coreLogger = {
    log,
    info,
    warn,
    fatal,
    debug,
    warnClient: (msg, obj) => {
        if (process.env.LUMIGO_WARNINGS === 'off') {
            debug('Does not warn the user about', msg);
            return false;
        }
        if (obj)
            // eslint-disable-next-line no-console
            console.log(`${WARN_CLIENT_PREFIX}: ${msg}`, obj);
        // eslint-disable-next-line no-console
        else
            console.log(`${WARN_CLIENT_PREFIX}: ${msg}`);
        return true;
    },
    LOG_LEVELS: exports.LOG_LEVELS,
};
const setLogger = (logger) => (coreLogger = logger);
exports.setLogger = setLogger;
const setLoggerPrefix = (prefix) => (LOG_PREFIX = prefix);
exports.setLoggerPrefix = setLoggerPrefix;
const getLogger = () => coreLogger;
exports.getLogger = getLogger;
//# sourceMappingURL=logger.js.map
{"version":3,"file":"httpUtils.js","sourceRoot":"","sources":["../../src/common/httpUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  getEventEntitySize,\n  isString,\n  LUMIGO_SECRET_MASKING_REGEX,\n  LUMIGO_SECRET_MASKING_REGEX_BACKWARD_COMP,\n  LUMIGO_WHITELIST_KEYS_REGEXES,\n  OMITTING_KEYS_REGEXES,\n  parseJsonFromEnvVar,\n} from '../utils';\nimport { safeExecute } from '../utils';\nimport { getLogger } from '../logger';\nimport untruncateJson from '../tools/untruncateJson';\nimport { Utf8Utils } from './utf8Utils';\nimport { HttpRawRequest, HttpRawResponse, RequestRawData } from '../types/spans';\nimport {\n  defaultSecretScrubber,\n  httpQueryParamsSecretScrubber,\n  httpRequestBodiesSecretScrubber,\n  httpRequestHeadersSecretScrubber,\n  httpResponseBodiesSecretScrubber,\n  httpResponseHeadersSecretScrubber,\n  processEnvironmentSecretScrubber,\n  SecretScrubber,\n  ScrubContext,\n} from './secrets';\n\nconst nativeTypes = ['string', 'bigint', 'number', 'undefined', 'boolean'];\nconst SCRUBBED_TEXT = '****';\nconst TRUNCATED_TEXT = '...[too long]';\n\nconst isNativeType = (obj) => nativeTypes.includes(typeof obj);\n\nconst keyToRegexes = (\n  regexesList = OMITTING_KEYS_REGEXES,\n  backwardCompRegexEnvVarName = LUMIGO_SECRET_MASKING_REGEX_BACKWARD_COMP,\n  regexesEnvVarName = LUMIGO_SECRET_MASKING_REGEX\n) => {\n  if (process.env[backwardCompRegexEnvVarName]) {\n    const parseResponse = parseJsonFromEnvVar(backwardCompRegexEnvVarName, true);\n    if (parseResponse) {\n      regexesList = parseResponse;\n    }\n  } else if (process.env[regexesEnvVarName]) {\n    const parseResponse = parseJsonFromEnvVar(regexesEnvVarName, true);\n    if (parseResponse) {\n      regexesList = parseResponse;\n    }\n  }\n  return regexesList.map((x) => new RegExp(x, 'i'));\n};\n\n/**\n * @deprecated Pass a `ScrubContext` instance to `scrub` or `payloadStringify`\n */\nexport const keyToOmitRegexes = (regexesEnvVarName = LUMIGO_SECRET_MASKING_REGEX) => {\n  return keyToRegexes();\n};\n\nconst whitelistKeysRegexes = () => {\n  return keyToRegexes([], null, LUMIGO_WHITELIST_KEYS_REGEXES);\n};\n\nexport const prune = (str: string | object, maxLength: number) => {\n  let toPrune = str;\n  if (!isString(toPrune)) {\n    getLogger().warn('Prune was called on a non-string object', toPrune);\n    toPrune = '';\n  }\n  return toPrune.substr(0, maxLength);\n};\n\nconst keyContainsRegex = (regexes, key) => {\n  if (!isNaN(key)) {\n    //optimization for arrays\n    return false;\n  }\n  return !!regexes.some((regex) => regex.test(key));\n};\n\n//Base64 calculation taken from : https://stackoverflow.com/questions/13378815/base64-length-calculation\nconst getNativeVarSize = (obj) => (obj ? (obj.toString().length * 4) / 3 : 0);\n\nconst getItemsInPath = safeExecute(\n  (payload, path) => {\n    if (!payload || !path) {\n      return [];\n    }\n    if (Array.isArray(path[0]) && Array.isArray(payload)) {\n      const newPath = path.slice(1);\n      return [].concat(...payload.map((i) => getItemsInPath(i, newPath)));\n    } else if (payload[path[0]]) {\n      if (path.length === 1) {\n        return [payload];\n      }\n      return getItemsInPath(payload[path[0]], path.slice(1));\n    }\n    return [];\n  },\n  'Failed to find items to skip scrubbing',\n  getLogger().LOG_LEVELS.WARNING,\n  []\n);\n\nexport const payloadStringify = (\n  payload: any,\n  maxPayloadSize = getEventEntitySize(),\n  skipScrubPath = null,\n  truncated = false,\n  scrubContext: ScrubContext = ScrubContext.DEFAULT\n) => {\n  let totalSize = 0;\n  const refsFound = [];\n\n  let secretScrubber: SecretScrubber;\n  switch (scrubContext) {\n    case ScrubContext.HTTP_REQUEST_BODY: {\n      secretScrubber = httpRequestBodiesSecretScrubber;\n      break;\n    }\n    case ScrubContext.HTTP_REQUEST_HEADERS: {\n      secretScrubber = httpRequestHeadersSecretScrubber;\n      break;\n    }\n    case ScrubContext.HTTP_REQUEST_QUERY: {\n      secretScrubber = httpQueryParamsSecretScrubber;\n      break;\n    }\n    case ScrubContext.HTTP_RESPONSE_BODY: {\n      secretScrubber = httpResponseBodiesSecretScrubber;\n      break;\n    }\n    case ScrubContext.HTTP_RESPONSE_HEADERS: {\n      secretScrubber = httpResponseHeadersSecretScrubber;\n      break;\n    }\n    case ScrubContext.PROCESS_ENVIRONMENT: {\n      secretScrubber = processEnvironmentSecretScrubber;\n      break;\n    }\n    default: {\n      secretScrubber = defaultSecretScrubber;\n      break;\n    }\n  }\n\n  const secretsRegexes = secretScrubber.expressions;\n  const whitelistRegexes = whitelistKeysRegexes();\n  const secretItemsToSkipScrubbing = new Set(getItemsInPath(payload, skipScrubPath));\n\n  let isPruned = false;\n  let result = JSON.stringify(payload, function (key, value) {\n    const type = typeof value;\n    const isObj = type === 'object';\n    const isStr = type === 'string';\n    const shouldSkipSecretScrub =\n      skipScrubPath &&\n      skipScrubPath[skipScrubPath.length - 1] === key &&\n      secretItemsToSkipScrubbing.has(this);\n    if (!(isObj && refsFound.includes(value))) {\n      if (totalSize < maxPayloadSize) {\n        if (\n          !shouldSkipSecretScrub &&\n          !keyContainsRegex(whitelistRegexes, key) &&\n          keyContainsRegex(secretsRegexes, key)\n        )\n          return SCRUBBED_TEXT;\n        if (isNativeType(value)) {\n          totalSize += getNativeVarSize(value);\n        }\n        if (isObj) {\n          refsFound.push(value);\n        }\n        if (value && isStr && value.length > maxPayloadSize) {\n          isPruned = true;\n          return prune(value, maxPayloadSize);\n        }\n        if (value instanceof Error)\n          return {\n            stack: prune(value.stack, maxPayloadSize),\n            message: value.message,\n          };\n\n        return value;\n      } else isPruned = true;\n    } else {\n      isPruned = true;\n    }\n  });\n  if (result && (isPruned || truncated)) {\n    result = result.replace(/,null/g, '');\n    result = result.concat(TRUNCATED_TEXT);\n  }\n  return result || '';\n};\n\nconst isJsonContent = (payload: any, headers: Object) => {\n  return isString(payload) && headers['content-type'] && headers['content-type'].includes('json');\n};\n\nexport function scrub(\n  payload: any,\n  headers: any,\n  sizeLimit: number,\n  truncated = false,\n  scrubContext?: ScrubContext.HTTP_REQUEST_BODY | ScrubContext.HTTP_RESPONSE_BODY\n): string {\n  try {\n    if (isJsonContent(payload, headers)) {\n      if (truncated) payload = untruncateJson(payload);\n      return payloadStringify(JSON.parse(payload), sizeLimit, null, truncated, scrubContext);\n    } else {\n      return payloadStringify(payload, sizeLimit, null, truncated, scrubContext);\n    }\n  } catch (e) {\n    return payloadStringify(payload, sizeLimit, null, truncated, scrubContext);\n  }\n}\n\nexport function scrubRequestDataPayload(\n  requestData: HttpRawRequest | HttpRawResponse,\n  scrubContext?: ScrubContext.HTTP_REQUEST_BODY | ScrubContext.HTTP_RESPONSE_BODY\n): string {\n  const { truncated, headers, body: payload } = requestData;\n  const isError = spanHasErrors(requestData);\n  const sizeLimit = getEventEntitySize(isError);\n  if (!scrubContext) {\n    // Best we can do in this case is to guess based on whether we have a statusCode (and hence it is a response).\n    scrubContext = (requestData as HttpRawResponse).statusCode\n      ? ScrubContext.HTTP_RESPONSE_BODY\n      : ScrubContext.HTTP_REQUEST_BODY;\n  }\n  return scrub(decodeHttpBody(payload, isError), headers, sizeLimit, truncated, scrubContext);\n}\n\nexport const spanHasErrors = (requestRawData: RequestRawData) =>\n  !!(requestRawData.hasError || requestRawData.response?.statusCode >= 400);\n\nexport const decodeHttpBody = (httpBody: any, hasError: boolean): any | string => {\n  if (isString(httpBody) && httpBody.length < getEventEntitySize(hasError)) {\n    return Utf8Utils.safeDecode(httpBody);\n  }\n  return httpBody;\n};\n"]}
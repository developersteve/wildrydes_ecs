"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeHttpBody = exports.spanHasErrors = exports.scrubRequestDataPayload = exports.scrub = exports.payloadStringify = exports.prune = exports.keyToOmitRegexes = void 0;
const utils_1 = require("../utils");
const utils_2 = require("../utils");
const logger_1 = require("../logger");
const untruncateJson_1 = require("../tools/untruncateJson");
const utf8Utils_1 = require("./utf8Utils");
const secrets_1 = require("./secrets");
const nativeTypes = ['string', 'bigint', 'number', 'undefined', 'boolean'];
const SCRUBBED_TEXT = '****';
const TRUNCATED_TEXT = '...[too long]';
const isNativeType = (obj) => nativeTypes.includes(typeof obj);
const keyToRegexes = (regexesList = utils_1.OMITTING_KEYS_REGEXES, backwardCompRegexEnvVarName = utils_1.LUMIGO_SECRET_MASKING_REGEX_BACKWARD_COMP, regexesEnvVarName = utils_1.LUMIGO_SECRET_MASKING_REGEX) => {
    if (process.env[backwardCompRegexEnvVarName]) {
        const parseResponse = (0, utils_1.parseJsonFromEnvVar)(backwardCompRegexEnvVarName, true);
        if (parseResponse) {
            regexesList = parseResponse;
        }
    }
    else if (process.env[regexesEnvVarName]) {
        const parseResponse = (0, utils_1.parseJsonFromEnvVar)(regexesEnvVarName, true);
        if (parseResponse) {
            regexesList = parseResponse;
        }
    }
    return regexesList.map((x) => new RegExp(x, 'i'));
};
/**
 * @deprecated Pass a `ScrubContext` instance to `scrub` or `payloadStringify`
 */
const keyToOmitRegexes = (regexesEnvVarName = utils_1.LUMIGO_SECRET_MASKING_REGEX) => {
    return keyToRegexes();
};
exports.keyToOmitRegexes = keyToOmitRegexes;
const whitelistKeysRegexes = () => {
    return keyToRegexes([], null, utils_1.LUMIGO_WHITELIST_KEYS_REGEXES);
};
const prune = (str, maxLength) => {
    let toPrune = str;
    if (!(0, utils_1.isString)(toPrune)) {
        (0, logger_1.getLogger)().warn('Prune was called on a non-string object', toPrune);
        toPrune = '';
    }
    return toPrune.substr(0, maxLength);
};
exports.prune = prune;
const keyContainsRegex = (regexes, key) => {
    if (!isNaN(key)) {
        //optimization for arrays
        return false;
    }
    return !!regexes.some((regex) => regex.test(key));
};
//Base64 calculation taken from : https://stackoverflow.com/questions/13378815/base64-length-calculation
const getNativeVarSize = (obj) => (obj ? (obj.toString().length * 4) / 3 : 0);
const getItemsInPath = (0, utils_2.safeExecute)((payload, path) => {
    if (!payload || !path) {
        return [];
    }
    if (Array.isArray(path[0]) && Array.isArray(payload)) {
        const newPath = path.slice(1);
        return [].concat(...payload.map((i) => getItemsInPath(i, newPath)));
    }
    else if (payload[path[0]]) {
        if (path.length === 1) {
            return [payload];
        }
        return getItemsInPath(payload[path[0]], path.slice(1));
    }
    return [];
}, 'Failed to find items to skip scrubbing', (0, logger_1.getLogger)().LOG_LEVELS.WARNING, []);
const payloadStringify = (payload, maxPayloadSize = (0, utils_1.getEventEntitySize)(), skipScrubPath = null, truncated = false, scrubContext = secrets_1.ScrubContext.DEFAULT) => {
    let totalSize = 0;
    const refsFound = [];
    let secretScrubber;
    switch (scrubContext) {
        case secrets_1.ScrubContext.HTTP_REQUEST_BODY: {
            secretScrubber = secrets_1.httpRequestBodiesSecretScrubber;
            break;
        }
        case secrets_1.ScrubContext.HTTP_REQUEST_HEADERS: {
            secretScrubber = secrets_1.httpRequestHeadersSecretScrubber;
            break;
        }
        case secrets_1.ScrubContext.HTTP_REQUEST_QUERY: {
            secretScrubber = secrets_1.httpQueryParamsSecretScrubber;
            break;
        }
        case secrets_1.ScrubContext.HTTP_RESPONSE_BODY: {
            secretScrubber = secrets_1.httpResponseBodiesSecretScrubber;
            break;
        }
        case secrets_1.ScrubContext.HTTP_RESPONSE_HEADERS: {
            secretScrubber = secrets_1.httpResponseHeadersSecretScrubber;
            break;
        }
        case secrets_1.ScrubContext.PROCESS_ENVIRONMENT: {
            secretScrubber = secrets_1.processEnvironmentSecretScrubber;
            break;
        }
        default: {
            secretScrubber = secrets_1.defaultSecretScrubber;
            break;
        }
    }
    const secretsRegexes = secretScrubber.expressions;
    const whitelistRegexes = whitelistKeysRegexes();
    const secretItemsToSkipScrubbing = new Set(getItemsInPath(payload, skipScrubPath));
    let isPruned = false;
    let result = JSON.stringify(payload, function (key, value) {
        const type = typeof value;
        const isObj = type === 'object';
        const isStr = type === 'string';
        const shouldSkipSecretScrub = skipScrubPath &&
            skipScrubPath[skipScrubPath.length - 1] === key &&
            secretItemsToSkipScrubbing.has(this);
        if (!(isObj && refsFound.includes(value))) {
            if (totalSize < maxPayloadSize) {
                if (!shouldSkipSecretScrub &&
                    !keyContainsRegex(whitelistRegexes, key) &&
                    keyContainsRegex(secretsRegexes, key))
                    return SCRUBBED_TEXT;
                if (isNativeType(value)) {
                    totalSize += getNativeVarSize(value);
                }
                if (isObj) {
                    refsFound.push(value);
                }
                if (value && isStr && value.length > maxPayloadSize) {
                    isPruned = true;
                    return (0, exports.prune)(value, maxPayloadSize);
                }
                if (value instanceof Error)
                    return {
                        stack: (0, exports.prune)(value.stack, maxPayloadSize),
                        message: value.message,
                    };
                return value;
            }
            else
                isPruned = true;
        }
        else {
            isPruned = true;
        }
    });
    if (result && (isPruned || truncated)) {
        result = result.replace(/,null/g, '');
        result = result.concat(TRUNCATED_TEXT);
    }
    return result || '';
};
exports.payloadStringify = payloadStringify;
const isJsonContent = (payload, headers) => {
    return (0, utils_1.isString)(payload) && headers['content-type'] && headers['content-type'].includes('json');
};
function scrub(payload, headers, sizeLimit, truncated = false, scrubContext) {
    try {
        if (isJsonContent(payload, headers)) {
            if (truncated)
                payload = (0, untruncateJson_1.default)(payload);
            return (0, exports.payloadStringify)(JSON.parse(payload), sizeLimit, null, truncated, scrubContext);
        }
        else {
            return (0, exports.payloadStringify)(payload, sizeLimit, null, truncated, scrubContext);
        }
    }
    catch (e) {
        return (0, exports.payloadStringify)(payload, sizeLimit, null, truncated, scrubContext);
    }
}
exports.scrub = scrub;
function scrubRequestDataPayload(requestData, scrubContext) {
    const { truncated, headers, body: payload } = requestData;
    const isError = (0, exports.spanHasErrors)(requestData);
    const sizeLimit = (0, utils_1.getEventEntitySize)(isError);
    if (!scrubContext) {
        // Best we can do in this case is to guess based on whether we have a statusCode (and hence it is a response).
        scrubContext = requestData.statusCode
            ? secrets_1.ScrubContext.HTTP_RESPONSE_BODY
            : secrets_1.ScrubContext.HTTP_REQUEST_BODY;
    }
    return scrub((0, exports.decodeHttpBody)(payload, isError), headers, sizeLimit, truncated, scrubContext);
}
exports.scrubRequestDataPayload = scrubRequestDataPayload;
const spanHasErrors = (requestRawData) => { var _a; return !!(requestRawData.hasError || ((_a = requestRawData.response) === null || _a === void 0 ? void 0 : _a.statusCode) >= 400); };
exports.spanHasErrors = spanHasErrors;
const decodeHttpBody = (httpBody, hasError) => {
    if ((0, utils_1.isString)(httpBody) && httpBody.length < (0, utils_1.getEventEntitySize)(hasError)) {
        return utf8Utils_1.Utf8Utils.safeDecode(httpBody);
    }
    return httpBody;
};
exports.decodeHttpBody = decodeHttpBody;
//# sourceMappingURL=httpUtils.js.map
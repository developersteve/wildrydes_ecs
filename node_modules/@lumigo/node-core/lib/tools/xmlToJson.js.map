{"version":3,"file":"xmlToJson.js","sourceRoot":"","sources":["../../src/tools/xmlToJson.js"],"names":[],"mappings":"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","sourcesContent":["/*\n  XML TO JSON\n  Taken from: https://github.com/alabianca/xml-to-json with tests\n  Be aware, this code is not 100% covered by tests\n*/\n\nconst clean = function cleanXML(xml) {\n  return xml\n    .replace(/>\\s*</g, '><') //remove white spaces between elements\n    .replace(/<\\?xml.*\\?>/g, '') //remove the root element\n    .replace(/<!--.*-->/g, '') //remove comments\n    .replace(/>\\s*/g, '>') // remove any white spaces at the end of the xml string if any\n    .replace(/\\s*</g, '<'); // remove any white spaces that are left at the beginning of the xml string\n};\n\nexport const traverse = (xml, attributeMode) => {\n  xml = clean(xml);\n  const tagFinder = new RegExp('<(.*?)[>|\\\\s|/]', 'g'); //find the current tag we are working on\n\n  const json = {};\n  let tagShouldBeArray = false;\n\n  //recursion base case\n  if (xml === '' || (xml.charAt(0) !== '<' && xml.charAt(xml.length - 1) !== '>')) {\n    return xml;\n  }\n\n  var currentLevelTags;\n  var skip = 0;\n  while ((currentLevelTags = tagFinder.exec(xml)) !== null) {\n    let selfClosing = false;\n    const tag = currentLevelTags[1];\n\n    const finishTag = '</' + tag + '>';\n    const input = currentLevelTags.input;\n    const tagLength = input.indexOf('>', skip) + 1;\n\n    const start = currentLevelTags.index;\n    const end = currentLevelTags.input.indexOf('>', start) + 1;\n    const currentTag = currentLevelTags.input.substring(start, end);\n\n    selfClosing = isSelfClosing(currentTag);\n\n    if (!validate(currentTag)) {\n      const err = new Error('Invalid XML tag');\n      throw err;\n    }\n    //const closingTagIndex = input.indexOf(finishTag,tagLength);\n    const closingTagIndex = findClosingIndex(input, finishTag, tagLength);\n    if (selfClosing === false && closingTagIndex < 0) {\n      return {};\n    }\n\n    let substring; //substring will be either all child tags or if self closing tag just a blank string. i.e: <employee><name>Alex</name></employee> : <name>Alex</name> will be the substring of the <employee> parent tag\n    if (selfClosing) {\n      substring = '';\n      skip = currentTag.length + skip;\n    } else {\n      substring = input.substring(input.indexOf('>', skip) + 1, closingTagIndex);\n      skip = tagLength + substring.length + finishTag.length;\n    }\n\n    tagFinder.lastIndex = skip; //skip all child tags of current level\n\n    if (!json[tag]) {\n      json[tag] = {};\n    } else {\n      tagShouldBeArray = true;\n    }\n\n    let temporary = {};\n    let attributes;\n    if (attributeMode) {\n      attributes = collectAttributes(currentTag);\n    }\n\n    //if currentTag contains attributes and attributeMode is enabled, attach them to json\n    if (tagShouldBeArray && attributeMode) {\n      temporary = attributes;\n    } else if (!tagShouldBeArray && attributeMode) {\n      for (let key in attributes) {\n        json[tag][key] = attributes[key];\n      }\n    }\n\n    //go one level deeper\n    const next = traverse(substring, attributeMode);\n\n    //when returning from recursion, build up the json\n\n    if (typeof next === 'object') {\n      //const key = Object.keys(next)[0];\n      if (tagShouldBeArray && !json[tag].length) {\n        const temp = json[tag];\n        json[tag] = [temp];\n        const nextObj = {};\n        for (let key in next) {\n          nextObj[key] = next[key];\n        }\n        temporary = { ...temporary, ...nextObj };\n        json[tag].push(temporary);\n      } else if (tagShouldBeArray) {\n        const nextObj = {};\n        for (let key in next) {\n          nextObj[key] = next[key];\n        }\n        temporary = { ...temporary, ...nextObj };\n        json[tag].push(temporary);\n      } else {\n        for (let key in next) {\n          json[tag][key] = next[key];\n        }\n      }\n    } else if (Object.keys(json[tag]).length > 0) {\n      if ((tagShouldBeArray && !json[tag].length) || typeof json[tag] === 'string') {\n        const temp = json[tag];\n        json[tag] = [temp];\n\n        if (typeof next !== 'object') {\n          if (Object.keys(temporary).length === 0) {\n            json[tag].push(next);\n          } else {\n            // temporary['data'] = next;\n            if (next !== '') {\n              temporary['textNode'] = next;\n            }\n            json[tag].push(temporary);\n          }\n        } else {\n          temporary = { ...temporary, next };\n          json[tag].push(next);\n        }\n        //json[tag].push(next);\n      } else if (tagShouldBeArray) {\n        //json[tag].push(next);\n        if (typeof next !== 'object') {\n          if (Object.keys(temporary).length === 0) {\n            json[tag].push(next);\n          } else {\n            //temporary['data'] = next;\n            if (next !== '') {\n              temporary['textNode'] = next;\n            }\n            json[tag].push(temporary);\n          }\n        } else {\n          temporary = { ...temporary, next };\n          json[tag].push(next);\n        }\n      } else {\n        if (next !== '') {\n          json[tag] = {\n            ...json[tag],\n            textNode: next,\n          };\n        }\n      }\n    } else {\n      if (tagShouldBeArray && typeof json[tag] !== 'object') {\n        const temp = json[tag];\n        json[tag] = [];\n        json[tag].push(...temp, next);\n      } else {\n        json[tag] = next;\n      }\n      //json[tag] = next;\n    }\n  }\n\n  return json;\n};\n\n//Helper methods\n\n//Determine if a tag is self closing or not. Could be improved\nfunction isSelfClosing(currentTag) {\n  if (currentTag.indexOf('/>') > -1) {\n    return true;\n  }\n  return false;\n}\n\n//Collect all the attributes of the current tag and return an object in form of {attribute:values}\nfunction collectAttributes(currentTag) {\n  const attributeFinder = new RegExp('(\\\\S*)=\"(.*?)\"', 'g');\n  const foundAttributes = {};\n\n  let attributes;\n  while ((attributes = attributeFinder.exec(currentTag)) !== null) {\n    const key = attributes[1];\n    const value = attributes[2];\n\n    foundAttributes[key] = value;\n  }\n\n  return foundAttributes;\n}\n\nfunction validate(currentTag) {\n  if (\n    currentTag.charAt(0) === '<' &&\n    currentTag.charAt(1) === '?' &&\n    currentTag.charAt(currentTag.length - 1) === '>' &&\n    currentTag.charAt(currentTag.length - 2) === '?'\n  ) {\n    return true;\n  }\n\n  if (\n    currentTag.charAt(0) === '<' &&\n    (currentTag.charAt(currentTag.length - 2) + currentTag.charAt(currentTag.length - 1) === '/>' ||\n      currentTag.charAt(currentTag.length - 1) === '>')\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction findClosingIndex(searchString, tag, start) {\n  const openinTag = tag.replace('</', '<').replace('>', '');\n  let closingIndex = searchString.indexOf(tag, start);\n  let openingIndex = searchString.indexOf(openinTag, start);\n\n  if (closingIndex < openingIndex) {\n    return closingIndex;\n  }\n\n  const sub = searchString.substr(openingIndex, closingIndex - openingIndex);\n\n  if (!sub.match(new RegExp(openinTag + '\\\\W'))) {\n    return closingIndex;\n  }\n\n  while (closingIndex > 0) {\n    const tempIndex = searchString.indexOf(tag, closingIndex + 1);\n    if (tempIndex > 0) {\n      closingIndex = tempIndex;\n    } else {\n      break;\n    }\n  }\n\n  return closingIndex;\n}\n"]}
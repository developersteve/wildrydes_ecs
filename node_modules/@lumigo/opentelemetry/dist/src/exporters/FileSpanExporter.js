"use strict";
/*
 * Copyright Lumigo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSpanExporter = void 0;
const fs_1 = __importDefault(require("fs"));
const core_1 = require("@opentelemetry/core");
const logging_1 = require("../logging");
/**
 * This is implementation of {@link SpanExporter} that prints spans to a file.
 * This class can be used for debug purposes. It is not advised to use this
 * exporter in production.
 */
/* eslint-disable no-console */
class FileSpanExporter {
    constructor(file) {
        this._file = file;
        this._fd = fs_1.default.openSync(file, 'w');
        this.shutdown = this.shutdown.bind(this);
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
    }
    /**
     * Export spans.
     * @param spans
     * @param resultCallback
     */
    export(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
    }
    /**
     * converts span info into more readable format
     * @param span
     */
    _exportInfo(span) {
        return {
            traceId: span.spanContext().traceId,
            parentId: span.parentSpanId,
            name: span.name,
            id: span.spanContext().spanId,
            kind: span.kind,
            timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
            duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
            attributes: span.attributes,
            status: span.status,
            events: span.events,
            resource: span.resource,
        };
    }
    /**
     * Store spans in file
     * @param spans
     * @param done
     */
    _sendSpans(spans, done) {
        let json = '';
        for (const span of spans) {
            json += JSON.stringify(this._exportInfo(span), undefined, 0);
            json += '\n';
        }
        fs_1.default.appendFile(this._fd, json, (err) => __awaiter(this, void 0, void 0, function* () {
            if (done) {
                if (err) {
                    return done({
                        code: core_1.ExportResultCode.FAILED,
                        error: err,
                    });
                }
                else {
                    fs_1.default.closeSync(this._fd);
                    this._fd = fs_1.default.openSync(this._file, 'a');
                    return done({ code: core_1.ExportResultCode.SUCCESS });
                }
            }
        }));
    }
    forceFlush() {
        if (this._shutdownOnce.isCalled) {
            return this._shutdownOnce.promise;
        }
        return this._flushAll();
    }
    /**
     * Shutdown the exporter.
     */
    shutdown() {
        return this._shutdownOnce.call();
    }
    /**
     * Called by _shutdownOnce with BindOnceFuture
     */
    _shutdown() {
        return Promise.resolve()
            .then(() => {
            return this._flushAll();
        })
            .finally(() => {
            if (this._fd) {
                fs_1.default.closeSync(this._fd);
            }
        });
    }
    _flushAll() {
        return Promise.resolve().then(() => {
            if (this._fd) {
                try {
                    return fs_1.default.fdatasyncSync(this._fd);
                }
                catch (e) {
                    logging_1.logger.error(`Cannot export log spandump`, e);
                }
            }
        });
    }
}
exports.FileSpanExporter = FileSpanExporter;
// From https://github.com/open-telemetry/opentelemetry-js/blob/d61f7bee0f7f60fed794d956e122decd0ce6748f/packages/opentelemetry-core/src/utils/callback.ts,
// TODO Replace with the opentelemetry-js SDK version when we upgrade
class BindOnceFuture {
    constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
    }
    get isCalled() {
        return this._isCalled;
    }
    get promise() {
        return this._deferred.promise;
    }
    call(...args) {
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    }
}
// From https://github.com/open-telemetry/opentelemetry-js/blob/d61f7bee0f7f60fed794d956e122decd0ce6748f/packages/opentelemetry-core/src/utils/promise.ts,
// TODO Replace with the opentelemetry-js SDK version when we upgrade
class Deferred {
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    get promise() {
        return this._promise;
    }
    resolve(val) {
        this._resolve(val);
    }
    reject(err) {
        this._reject(err);
    }
}
//# sourceMappingURL=FileSpanExporter.js.map
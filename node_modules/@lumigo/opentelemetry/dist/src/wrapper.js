"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const resources_1 = require("@opentelemetry/resources");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const dependencies_1 = require("./dependencies");
const exporters_1 = require("./exporters");
const ExpressInstrumentation_1 = __importDefault(require("./instrumentations/express/ExpressInstrumentation"));
const HttpInstrumentation_1 = __importDefault(require("./instrumentations/https/HttpInstrumentation"));
const MongoDBInstrumentation_1 = __importDefault(require("./instrumentations/mongodb/MongoDBInstrumentation"));
const utils_1 = require("./utils");
const awsResourceDetectors = __importStar(require("@opentelemetry/resource-detector-aws"));
const detectors_1 = require("./resources/detectors");
const w3cTraceContextPropagator_1 = require("./propagator/w3cTraceContextPropagator");
const LumigoDistroDetector_1 = require("./resources/detectors/LumigoDistroDetector");
const node_core_1 = require("@lumigo/node-core");
const DEFAULT_LUMIGO_ENDPOINT = 'https://ga-otlp.lumigo-tracer-edge.golumigo.com/v1/traces';
const DEFAULT_DEPENDENCIES_ENDPOINT = 'https://ga-otlp.lumigo-tracer-edge.golumigo.com/v1/dependencies';
const logging_1 = require("./logging");
const lumigoEndpoint = process.env.LUMIGO_ENDPOINT || DEFAULT_LUMIGO_ENDPOINT;
let isTraceInitialized = false;
function reportInitError(err) {
    logging_1.logger.error('An error occurred while initializing the Lumigo OpenTelemetry Distro: no telemetry will be collected and sent to Lumigo.', err);
}
const trace = () => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    if (!isTraceInitialized) {
        isTraceInitialized = true;
        try {
            if (((_a = process.env.LUMIGO_SWITCH_OFF) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'true') {
                logging_1.logger.info('The Lumigo OpenTelemetry Distro is switched off (the "LUMIGO_SWITCH_OFF" environment variable is set): no telemetry will be sent to Lumigo.');
                return;
            }
            const instrumentationsToInstall = [
                new HttpInstrumentation_1.default(new URL(lumigoEndpoint).hostname),
                new ExpressInstrumentation_1.default(),
                new MongoDBInstrumentation_1.default(),
            ].filter((i) => i.isApplicable());
            /*
             * Register instrumentation globally, so that all tracer providers
             * will receive traces. This may be necessary when there is already
             * built-in instrumentation in the app.
             */
            (0, instrumentation_1.registerInstrumentations)({
                instrumentations: instrumentationsToInstall.map((i) => i.getInstrumentation()),
            });
            const instrumentedModules = instrumentationsToInstall.map((i) => i.getInstrumentedModule());
            logging_1.logger.debug(`Instrumented modules: ${instrumentedModules.join(', ')}`);
            const lumigoToken = process.env.LUMIGO_TRACER_TOKEN;
            if (!lumigoToken) {
                logging_1.logger.warn('The Lumigo token is not available (the "LUMIGO_TRACER_TOKEN" environment variable is not set): no telemetry will be sent to Lumigo.');
            }
            const lumigoReportDependencies = ((_b = process.env.LUMIGO_REPORT_DEPENDENCIES) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== 'false';
            const detectedResource = resources_1.Resource.default().merge(yield (0, resources_1.detectResources)({
                detectors: [
                    resources_1.envDetector,
                    resources_1.processDetector,
                    awsResourceDetectors.awsEcsDetector,
                    new detectors_1.LumigoDistroDetector(),
                    new detectors_1.LumigoKubernetesDetector(),
                ],
            }));
            const framework = instrumentedModules.includes('express') ? 'express' : 'node';
            const tracerProvider = new sdk_trace_node_1.NodeTracerProvider({
                resource: detectedResource.merge(new resources_1.Resource({
                    framework,
                    'process.environ': node_core_1.CommonUtils.payloadStringify((0, utils_1.extractEnvVars)(), 20000),
                })),
                spanLimits: {
                    attributeValueLengthLimit: (0, utils_1.getMaxSize)(),
                },
            });
            tracerProvider.register({
                propagator: new w3cTraceContextPropagator_1.LumigoW3CTraceContextPropagator(),
            });
            if (process.env.LUMIGO_DEBUG_SPANDUMP) {
                tracerProvider.addSpanProcessor(new sdk_trace_base_1.SimpleSpanProcessor(new exporters_1.FileSpanExporter(process.env.LUMIGO_DEBUG_SPANDUMP)));
            }
            let reportDependencies;
            if (lumigoToken) {
                const otlpExporter = new exporter_trace_otlp_http_1.OTLPTraceExporter({
                    url: lumigoEndpoint,
                    headers: {
                        Authorization: `LumigoToken ${lumigoToken.trim()}`,
                    },
                });
                tracerProvider.addSpanProcessor(new sdk_trace_base_1.BatchSpanProcessor(otlpExporter, {
                    // The maximum queue size. After the size is reached spans are dropped.
                    maxQueueSize: 1000,
                    // The maximum batch size of every export. It must be smaller or equal to maxQueueSize.
                    maxExportBatchSize: 100,
                }));
                /*
                 * We do not wait for this promise, we do not want to delay the application.
                 * Dependency reporting is done "best effort".
                 */
                if (!lumigoReportDependencies) {
                    reportDependencies = Promise.resolve('Dependency reporting is turned off');
                }
                else if (lumigoEndpoint === DEFAULT_LUMIGO_ENDPOINT) {
                    /*
                     * If the trace endpoint is different than the default, it could be
                     * that this application does not have egress to Lumigo SaaS or it is
                     * reporting to a backend that is not Lumigo, and thus does not have
                     * the facilities to process the dependencies anyways. In this case,
                     * skip the reporting, as it might not work and cause noise in the logs.
                     *
                     * We pass `detectedResource` as opposed to `tracerProvider.resource`
                     * because we want only the infrastructure-related resource attributes
                     * like ARNs, and specifically we do not need the process environment.
                     */
                    reportDependencies = (0, dependencies_1.report)(DEFAULT_DEPENDENCIES_ENDPOINT, lumigoToken, detectedResource.attributes);
                }
            }
            else {
                reportDependencies = Promise.resolve('No Lumigo token available');
            }
            tracerProvider.register();
            const distroVersion = detectedResource && detectedResource.attributes
                ? detectedResource.attributes[LumigoDistroDetector_1.LUMIGO_DISTRO_VERSION]
                : 'unknown';
            logging_1.logger.info(`Lumigo tracer v${distroVersion} started.`);
            return Promise.resolve({
                tracerProvider,
                reportDependencies,
                instrumentedModules,
            });
        }
        catch (err) {
            reportInitError(err);
            return Promise.reject(err);
        }
    }
    else {
        logging_1.logger.debug('The Lumigo OpenTelemetry Distro is already initialized: additional attempt to initialize has been ignored.');
    }
});
exports.init = trace();
//# sourceMappingURL=wrapper.js.map
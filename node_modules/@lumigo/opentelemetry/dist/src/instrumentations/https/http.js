"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Http = exports.HttpHooks = exports.isEmptyString = exports.isEncodingType = exports.isValidHttpRequestBody = void 0;
const http_1 = require("http");
const shimmer = __importStar(require("shimmer"));
const url_1 = require("url");
const node_core_1 = require("@lumigo/node-core");
const logging_1 = require("../../logging");
const awsSpan_1 = require("../../spans/awsSpan");
const utils_1 = require("../../utils");
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
const isFunctionAlreadyWrapped = (fn) => fn && fn.__wrapped;
const hook = (module, funcName, options = {}, shimmerLib = shimmer) => {
    const { beforeHook = noop, afterHook = noop } = options;
    const safeBeforeHook = (0, utils_1.safeExecute)(beforeHook, `before hook of ${funcName} fail`);
    const safeAfterHook = (0, utils_1.safeExecute)(afterHook, `after hook of ${funcName} fail`);
    const extenderContext = {};
    try {
        const wrapper = (originalFn) => {
            if (isFunctionAlreadyWrapped(originalFn))
                return originalFn;
            return function (...args) {
                safeBeforeHook.call(this, args, extenderContext);
                const originalFnResult = originalFn.apply(this, args);
                safeAfterHook.call(this, args, originalFnResult, extenderContext);
                return originalFnResult;
            };
        };
        shimmerLib.wrap(module, funcName, wrapper);
    }
    catch (e) {
        logging_1.logger.warn(`Wrapping of function ${funcName} failed`, options);
    }
};
const isValidHttpRequestBody = (reqBody) => !!(reqBody && (typeof reqBody === 'string' || reqBody instanceof Buffer));
exports.isValidHttpRequestBody = isValidHttpRequestBody;
const isEncodingType = (encodingType) => !!(encodingType &&
    typeof encodingType === 'string' &&
    ['ascii', 'utf8', 'utf16le', 'ucs2', 'base64', 'binary', 'hex'].includes(encodingType));
exports.isEncodingType = isEncodingType;
const isEmptyString = (str) => !!(!str || (typeof str === 'string' && str.length === 0));
exports.isEmptyString = isEmptyString;
exports.HttpHooks = {
    requestHook(span, request) {
        if (request instanceof http_1.ClientRequest) {
            (0, utils_1.safeExecute)(() => {
                var _a, _b, _c;
                const requestData = {
                    request: {
                        path: (_a = span.attributes) === null || _a === void 0 ? void 0 : _a['http.target'],
                        host: ((_b = span.attributes) === null || _b === void 0 ? void 0 : _b['http.host']) || ((_c = span.attributes) === null || _c === void 0 ? void 0 : _c['net.peer.name']),
                        truncated: false,
                        body: '',
                        headers: Http.getRequestHeaders(request),
                    },
                    response: {
                        truncated: false,
                        body: '',
                        headers: {},
                    },
                };
                const scrubbedHeaders = node_core_1.CommonUtils.payloadStringify(requestData.request.headers);
                span.setAttribute('http.request.headers', scrubbedHeaders);
                const emitWrapper = Http.httpRequestEmitBeforeHookWrapper(requestData, span);
                const writeWrapper = Http.httpRequestWriteBeforeHookWrapper(requestData, span);
                const endWrapper = (requestData, span) => {
                    return function (args) {
                        if ((0, exports.isEmptyString)(requestData.request.body)) {
                            const body = Http.extractBodyFromWriteOrEndFunc(args);
                            requestData.request.body += body;
                            const scrubbed = node_core_1.CommonUtils.scrubRequestDataPayload(requestData.request);
                            span.setAttribute('http.request.body', scrubbed);
                        }
                    };
                };
                hook(request, 'end', { beforeHook: endWrapper });
                hook(request, 'emit', { beforeHook: emitWrapper });
                hook(request, 'write', { beforeHook: writeWrapper });
            })();
        }
    },
    responseHook(span, response) {
        const scrubbedHeaders = node_core_1.CommonUtils.payloadStringify(response.headers);
        if (response.headers) {
            span.setAttribute('http.response.headers', scrubbedHeaders);
        }
    },
};
class Http {
    static onRequestEnd(span) {
        return (requestRawData, options) => {
            var _a;
            const { body, headers, statusCode, truncated } = options;
            requestRawData.response.body = body;
            requestRawData.response.headers = headers;
            requestRawData.response.statusCode = statusCode;
            requestRawData.response.truncated = truncated;
            const scrubbed = node_core_1.CommonUtils.scrubRequestDataPayload(requestRawData.response);
            span.setAttribute('http.response.body', scrubbed);
            try {
                if ((0, utils_1.isAwsService)(requestRawData.request.host, requestRawData.response)) {
                    span.setAttributes((0, awsSpan_1.getAwsServiceData)(requestRawData.request, requestRawData.response));
                    span.setAttribute('aws.region', (_a = span.attributes) === null || _a === void 0 ? void 0 : _a['http.host'].split('.')[1]);
                }
            }
            catch (e) {
                logging_1.logger.debug('Failed to parse aws service data', e);
                logging_1.logger.debug('getHttpSpan args', { requestData: requestRawData });
            }
        };
    }
    static extractBodyFromEmitSocketEvent(socketEventArgs) {
        return (0, utils_1.safeExecute)(() => {
            var _a, _b;
            if (socketEventArgs &&
                socketEventArgs._httpMessage &&
                socketEventArgs._httpMessage._hasBody) {
                const httpMessage = socketEventArgs._httpMessage;
                let lines = [];
                // eslint-disable-next-line no-prototype-builtins
                if (httpMessage.hasOwnProperty('outputData')) {
                    lines = ((_a = httpMessage.outputData[0]) === null || _a === void 0 ? void 0 : _a.data.split('\n')) || [];
                    // eslint-disable-next-line no-prototype-builtins
                }
                else if (httpMessage.hasOwnProperty('output')) {
                    lines = ((_b = httpMessage.output[0]) === null || _b === void 0 ? void 0 : _b.split('\n')) || [];
                }
                if (lines.length > 0) {
                    return lines[lines.length - 1];
                }
            }
        }, 'failed to extractBodyFromEmitSocketEvent', 'warn')();
    }
    static getRequestHeaders(request) {
        return request.headers || request.getHeaders();
    }
    static httpRequestArguments(args) {
        if (args.length === 0) {
            throw new Error('http/s.request(...) was called without any arguments.');
        }
        let url = undefined;
        let options = undefined;
        let callback = undefined;
        if (typeof args[0] === 'string' || args[0] instanceof url_1.URL) {
            url = args[0];
            if (args[1]) {
                if (typeof args[1] === 'function') {
                    callback = args[1];
                }
                else {
                    options = args[1];
                    if (typeof args[2] === 'function') {
                        callback = args[2];
                    }
                }
            }
        }
        else {
            options = args[0];
            if (typeof args[1] === 'function') {
                callback = args[1];
            }
        }
        return { url, options, callback };
    }
    static getHostFromOptionsOrUrl(options, url) {
        if (url) {
            return new url_1.URL(url).hostname;
        }
        return options.hostname || options.host || (options.uri && options.uri.hostname) || 'localhost';
    }
    static httpRequestWriteBeforeHookWrapper(requestData, span) {
        return function (args) {
            if ((0, exports.isEmptyString)(requestData.request.body)) {
                const body = Http.extractBodyFromWriteOrEndFunc(args);
                requestData.request.body += body;
                const scrubbed = node_core_1.CommonUtils.scrubRequestDataPayload(requestData.request);
                span.setAttribute('http.request.body', scrubbed);
            }
        };
    }
    static createEmitResponseOnEmitBeforeHookHandler(requestRawData, response, onRequestEnd) {
        let body = '';
        const maxPayloadSize = (0, utils_1.getMaxSize)();
        return function (args) {
            let truncated = false;
            const { headers, statusCode } = response;
            if (args[0] === 'data' && body.length < maxPayloadSize) {
                let chunk = args[1].toString();
                const allowedLengthToAdd = maxPayloadSize - body.length;
                //if we reached or close to limit get only substring of the part to reach the limit
                if (chunk.length > allowedLengthToAdd) {
                    truncated = true;
                    chunk = chunk.substr(0, allowedLengthToAdd);
                }
                body += chunk;
            }
            if (args[0] === 'end') {
                onRequestEnd(requestRawData, { body, truncated, headers, statusCode });
            }
        };
    }
    static createEmitResponseHandler(requestData, span) {
        return (response) => {
            const onHandler = Http.createEmitResponseOnEmitBeforeHookHandler(requestData, response, Http.onRequestEnd(span));
            hook(response, 'emit', {
                beforeHook: onHandler,
            });
        };
    }
    static httpRequestEmitBeforeHookWrapper(requestData, span) {
        const emitResponseHandler = Http.createEmitResponseHandler(requestData, span);
        const oneTimerEmitResponseHandler = (0, utils_1.runOneTimeWrapper)(emitResponseHandler, {});
        return function (args) {
            if (args[0] === 'response') {
                oneTimerEmitResponseHandler(args[1]);
            }
            if (args[0] === 'socket') {
                if ((0, exports.isEmptyString)(requestData.request.body)) {
                    const body = Http.extractBodyFromEmitSocketEvent(args[1]);
                    requestData.request.body += body;
                    const scrubbed = node_core_1.CommonUtils.scrubRequestDataPayload(requestData.request);
                    span.setAttribute('http.request.body', scrubbed);
                }
            }
        };
    }
}
exports.Http = Http;
Http.extractBodyFromWriteOrEndFunc = (writeEventArgs) => {
    return (0, utils_1.safeExecute)(() => {
        if ((0, exports.isValidHttpRequestBody)(writeEventArgs[0])) {
            const encoding = (0, exports.isEncodingType)(writeEventArgs[1]) ? writeEventArgs[1] : 'utf8';
            return typeof writeEventArgs[0] === 'string'
                ? new Buffer(writeEventArgs[0]).toString(encoding)
                : writeEventArgs[0].toString();
        }
    })();
};
//# sourceMappingURL=http.js.map
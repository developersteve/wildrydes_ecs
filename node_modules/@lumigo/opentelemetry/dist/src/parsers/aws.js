"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.awsParser = exports.kinesisParser = exports.sqsParser = exports.eventBridgeParser = exports.apigwParser = exports.snsParser = exports.lambdaParser = exports.extractLambdaNameFromArn = exports.isArn = exports.dynamodbParser = void 0;
const logging_1 = require("../logging");
const utils_1 = require("../utils");
const xmlToJson_1 = require("../tools/xmlToJson");
const node_core_1 = require("@lumigo/node-core");
const node_core_2 = require("@lumigo/node-core");
const extractDynamodbMessageId = (reqBody, method) => {
    if (method === 'PutItem' && reqBody['Item']) {
        return (0, utils_1.md5Hash)(reqBody.Item);
    }
    else if (method === 'UpdateItem' && reqBody['Key']) {
        return (0, utils_1.md5Hash)(reqBody.Key);
    }
    else if (method === 'DeleteItem' && reqBody['Key']) {
        return (0, utils_1.md5Hash)(reqBody.Key);
    }
    else if (method === 'BatchWriteItem') {
        const firstTableName = Object.keys(reqBody.RequestItems)[0];
        if (firstTableName) {
            const firstItem = reqBody.RequestItems[firstTableName][0];
            if (firstItem['PutRequest']) {
                return (0, utils_1.md5Hash)(firstItem.PutRequest.Item);
            }
            else if (firstItem['DeleteRequest']) {
                return (0, utils_1.md5Hash)(firstItem.DeleteRequest.Key);
            }
        }
    }
    return undefined;
};
const extractDynamodbTableName = (reqBody, method) => {
    const tableName = (reqBody['TableName'] && reqBody.TableName) || '';
    if (!tableName && ['BatchWriteItem', 'BatchGetItem'].includes(method)) {
        return Object.keys(reqBody.RequestItems)[0];
    }
    return tableName;
};
const dynamodbParser = (requestData) => {
    const { headers: reqHeaders, body: reqBody } = requestData;
    const dynamodbMethod = (reqHeaders['x-amz-target'] && reqHeaders['x-amz-target'].split('.')[1]) || '';
    const reqBodyJSON = (!!reqBody && JSON.parse(reqBody)) || {};
    const resourceName = extractDynamodbTableName(reqBodyJSON, dynamodbMethod);
    const messageId = extractDynamodbMessageId(reqBodyJSON, dynamodbMethod);
    return {
        'aws.resource.name': resourceName,
        'aws.dynamodb.method': dynamodbMethod,
        messageId,
    };
};
exports.dynamodbParser = dynamodbParser;
// non-official
const isArn = (arnToValidate) => {
    return arnToValidate.startsWith('arn:aws:');
};
exports.isArn = isArn;
const extractLambdaNameFromArn = (arn) => arn.split(':')[6];
exports.extractLambdaNameFromArn = extractLambdaNameFromArn;
const lambdaParser = (requestData, responseData) => {
    if (!responseData)
        return {};
    const { path, headers } = requestData;
    let resourceName = decodeURIComponent(path).split('/')[3];
    resourceName = (0, exports.isArn)(resourceName) ? (0, exports.extractLambdaNameFromArn)(resourceName) : resourceName;
    const { headers: responseHeaders } = responseData;
    const spanId = responseHeaders['x-amzn-requestid'] || responseHeaders['x-amz-requestid'] || '';
    const invocationType = headers['x-amz-invocation-type'];
    return {
        'aws.resource.name': resourceName,
        'aws.invocation.type': invocationType,
        'aws.request.id': spanId,
    };
};
exports.lambdaParser = lambdaParser;
const snsParser = (requestData, responseData) => {
    if (!responseData)
        return {};
    const { body: reqBody } = requestData;
    const { body: resBody } = responseData;
    const parsedRequestBody = reqBody ? (0, utils_1.parseQueryParams)(reqBody) : undefined;
    const parsedResponseBody = resBody ? (0, xmlToJson_1.traverse)(resBody) : undefined;
    const resourceName = parsedRequestBody ? parsedRequestBody['TopicArn'] : undefined;
    const messageId = parsedResponseBody
        ? ((parsedResponseBody['PublishResponse'] || {})['PublishResult'] || {})['MessageId']
        : undefined;
    return {
        'aws.resource.name': resourceName,
        'aws.targetArn': resourceName,
        messageId,
    };
};
exports.snsParser = snsParser;
const apigwParser = (requestData, responseData) => {
    if (!responseData)
        return {};
    let baseData = (0, exports.awsParser)(requestData, responseData);
    if (!baseData) {
        baseData = {};
    }
    if (!baseData.messageId) {
        const { headers: resHeader } = responseData;
        if (resHeader && resHeader['apigw-requestid']) {
            baseData.messageId = resHeader['apigw-requestid'];
        }
    }
    return baseData;
};
exports.apigwParser = apigwParser;
const eventBridgeParser = (requestData, responseData) => {
    const { body: reqBody } = requestData;
    const { body: resBody } = responseData || {};
    const reqBodyJSON = (!!reqBody && JSON.parse(reqBody)) || {};
    const resBodyJSON = (!!resBody && JSON.parse(resBody)) || {};
    const resourceNames = reqBodyJSON.Entries
        ? (0, utils_1.removeDuplicates)(reqBodyJSON.Entries.map((entry) => entry.EventBusName))
        : undefined;
    const messageIds = resBodyJSON.Entries
        ? resBodyJSON.Entries.map((entry) => entry.EventId)
        : undefined;
    return {
        'aws.resource.names': resourceNames,
        messageIds: messageIds,
    };
};
exports.eventBridgeParser = eventBridgeParser;
const sqsParser = (requestData, responseData) => {
    var _a, _b, _c;
    const { body: reqBody } = requestData;
    const { body: resBody } = responseData || {};
    const parsedReqBody = reqBody ? (0, utils_1.parseQueryParams)(reqBody) : undefined;
    const parsedResBody = resBody ? (0, xmlToJson_1.traverse)(resBody) : undefined;
    const resourceName = parsedReqBody ? parsedReqBody['QueueUrl'] : undefined;
    const awsServiceData = { 'aws.resource.name': resourceName };
    awsServiceData.messageId =
        (0, utils_1.safeGet)(parsedResBody, ['SendMessageResponse', 'SendMessageResult', 'MessageId'], undefined) ||
            (0, utils_1.safeGet)(parsedResBody, [
                'SendMessageBatchResponse',
                'SendMessageBatchResult',
                'SendMessageBatchResultEntry',
                0,
                'MessageId',
            ], undefined) ||
            (0, utils_1.safeGet)(parsedResBody, [
                'SendMessageBatchResponse',
                'SendMessageBatchResult',
                'SendMessageBatchResultEntry',
                'MessageId',
            ], undefined) ||
            (0, utils_1.safeGet)(parsedResBody, ['ReceiveMessageResponse', 'ReceiveMessageResult', 'Message', 'MessageId'], undefined) ||
            (0, utils_1.safeGet)(parsedResBody, ['ReceiveMessageResponse', 'ReceiveMessageResult', 'Message', 0, 'MessageId'], undefined);
    const innerRaw = ((_c = (_b = (_a = parsedResBody === null || parsedResBody === void 0 ? void 0 : parsedResBody.ReceiveMessageResponse) === null || _a === void 0 ? void 0 : _a.ReceiveMessageResult) === null || _b === void 0 ? void 0 : _b.Message) === null || _c === void 0 ? void 0 : _c.Body) || '';
    if (innerRaw.search(node_core_2.Triggers.INNER_MESSAGES_IDENTIFIER_PATTERN) > 0) {
        const inner = JSON.parse(innerRaw.replace(/&quot;/g, '"'));
        const mainTrigger = {
            id: node_core_1.CommonUtils.getRandomString(10),
            targetId: null,
            triggeredBy: node_core_2.Triggers.MessageTrigger.SQS,
            fromMessageIds: [awsServiceData.messageId],
            extra: { resource: resourceName },
        };
        awsServiceData.lumigoData = JSON.stringify({
            trigger: [mainTrigger, ...node_core_2.Triggers.recursiveParseTriggers(inner, mainTrigger.id)],
        });
    }
    return awsServiceData;
};
exports.sqsParser = sqsParser;
const kinesisParser = (requestData, responseData) => {
    const { body: reqBody } = requestData;
    const { body: resBody } = responseData;
    const reqBodyJSON = (!!reqBody && JSON.parse(reqBody)) || {};
    let resBodyJSON = {};
    try {
        resBodyJSON = (!!resBody && JSON.parse(resBody)) || {};
    }
    catch (e) {
        logging_1.logger.debug(`Unable to parse response, ${e}`);
        resBodyJSON = {};
    }
    const resourceName = (reqBodyJSON['StreamName'] && reqBodyJSON.StreamName) || undefined;
    const awsServiceData = { 'aws.resource.name': resourceName };
    if (resBodyJSON['SequenceNumber']) {
        // @ts-ignore
        awsServiceData.messageId = resBodyJSON['SequenceNumber'];
    }
    if (Array.isArray(resBodyJSON['Records'])) {
        // @ts-ignore
        awsServiceData.messageIds = resBodyJSON['Records']
            .map((r) => r['SequenceNumber'])
            .filter((x) => !!x);
    }
    return awsServiceData;
};
exports.kinesisParser = kinesisParser;
const awsParser = (requestData, responseData) => {
    if (!responseData)
        return {};
    const { headers: resHeader } = responseData;
    const messageId = resHeader
        ? resHeader['x-amzn-requestid'] || resHeader['x-amz-request-id']
        : undefined;
    return messageId ? { messageId } : {};
};
exports.awsParser = awsParser;
//# sourceMappingURL=aws.js.map
{"version":3,"file":"report.js","sourceRoot":"","sources":["../../../src/dependencies/report.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;;;AAEH;;;;;;;;;;;;;GAaG;AAEH,0CAA+D;AAC/D,oCAAmC;AAGnC,SAAsB,MAAM,CAC1B,oBAA4B,EAC5B,WAAmB,EACnB,kBAAsC;;QAEtC,MAAM,QAAQ,GAAG,MAAM,YAAY,EAAE,CAAC;QAEtC,OAAO,CACL,IAAA,eAAO,EACL,oBAAoB,EACpB,EAAE,kBAAkB,EAAE,QAAQ,EAAE,EAChC,EAAE,aAAa,EAAE,eAAe,WAAW,CAAC,IAAI,EAAE,EAAE,EAAE,CACvD;YACC,oBAAoB;aACnB,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC;QAClB,mBAAmB;SACpB,CAAC;IACJ,CAAC;CAAA;AAjBD,wBAiBC;AAED,SAAe,YAAY;;QACzB,MAAM,gBAAgB,GAAG,EAAE,CAAC;QAE5B,KAAK,MAAM,WAAW,IAAI,MAAM,CAAC,KAAK,EAAE;YACtC,IAAI;gBACF,iEAAiE;gBACjE,MAAM,IAAA,iBAAM,EAAC,WAAW,CAAC,CAAC;gBAC1B,8CAA8C;gBAC9C,MAAM,KAAK,GAAG,MAAM,IAAA,gBAAK,EAAC,WAAW,CAAC,CAAC;gBACvC,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE;oBACvB,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBACpC;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ;;;mBAGG;gBACH,SAAS;aACV;SACF;QAED,MAAM,QAAQ,GAAG,EAAE,CAAC;QACpB,KAAK,MAAM,WAAW,IAAI,gBAAgB,EAAE;YAC1C,MAAM,WAAW,GAAG,MAAM,IAAA,kBAAO,EAAC,WAAW,CAAC,CAAC;YAE/C,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;gBACpC,IAAI;oBACF,MAAM,eAAe,GAAG,GAAG,WAAW,IAAI,UAAU,eAAe,CAAC;oBACpE,MAAM,OAAO,GAAG,MAAM,IAAA,mBAAQ,EAAC,eAAe,CAAC,CAAC;oBAChD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;oBACnD,QAAQ,CAAC,IAAI,CAAC;wBACZ,IAAI,EAAE,WAAW,CAAC,IAAI;wBACtB,OAAO,EAAE,WAAW,CAAC,OAAO;qBAC7B,CAAC,CAAC;iBACJ;gBAAC,OAAO,GAAG,EAAE;oBACZ;;;;;;uBAMG;oBACH,SAAS;iBACV;aACF;SACF;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;CAAA","sourcesContent":["/*\n * Copyright Lumigo\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * To provide better support and better data-driven product decisions\n * with respect to which packages to support next, the Lumigo\n * OpenTelemetry Distro for JS will report to Lumigo on startup the\n * packages and their versions used in this application, together with the\n * OpenTelemetry resource data to enable analytics in terms of which platforms\n * use which dependencies.\n *\n * This behavior is opt-out using the `LUMIGO_REPORT_DEPENDENCIES=false`\n * environment variable. Additionally, data is sent only when the Lumigo endpoint\n * is the default one (as to avoid issues when tracing data is sent through proxies\n * like OpenTelemetry collectors), and it active only when a `LUMIGO_TRACER_TOKEN`\n * is present in the process environment.\n */\n\nimport { access, lstat, readFile, readdir } from 'fs/promises';\nimport { postUri } from '../utils';\nimport { ResourceAttributes } from '@opentelemetry/resources';\n\nexport async function report(\n  dependenciesEndpoint: string,\n  lumigoToken: string,\n  resourceAttributes: ResourceAttributes\n) {\n  const packages = await listPackages();\n\n  return (\n    postUri(\n      dependenciesEndpoint,\n      { resourceAttributes, packages },\n      { Authorization: `LumigoToken ${lumigoToken.trim()}` }\n    )\n      /* eslint-disable */\n      .catch(() => {})\n    /* eslint-enable */\n  );\n}\n\nasync function listPackages() {\n  const validModulePaths = [];\n\n  for (const modulesPath of module.paths) {\n    try {\n      // Basic existence check of the modulesPath (no actual FS access)\n      await access(modulesPath);\n      // Check if modulesPath is an actual directory\n      const stats = await lstat(modulesPath);\n      if (stats.isDirectory()) {\n        validModulePaths.push(modulesPath);\n      }\n    } catch (err) {\n      /*\n       * Likely it is a default option, like /node_modules,\n       * that does not actually exist.\n       */\n      continue;\n    }\n  }\n\n  const packages = [];\n  for (const modulesPath of validModulePaths) {\n    const packageDirs = await readdir(modulesPath);\n\n    for (const packageDir of packageDirs) {\n      try {\n        const packageJsonFile = `${modulesPath}/${packageDir}/package.json`;\n        const content = await readFile(packageJsonFile);\n        const packageJson = JSON.parse(content.toString());\n        packages.push({\n          name: packageJson.name,\n          version: packageJson.version,\n        });\n      } catch (err) {\n        /*\n         * Could be that the packageDir is actually not a directory,\n         * or that it does not contain a package.json file (so it is\n         * actually not a package directory), or that the package.json\n         * file is malformed. In any of these cases, it is not an actual\n         * dependency the application can load, so it is safe to skip.\n         */\n        continue;\n      }\n    }\n  }\n\n  return packages;\n}\n"]}
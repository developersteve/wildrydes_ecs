"use strict";
/*
 * Copyright Lumigo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.report = void 0;
/*
 * To provide better support and better data-driven product decisions
 * with respect to which packages to support next, the Lumigo
 * OpenTelemetry Distro for JS will report to Lumigo on startup the
 * packages and their versions used in this application, together with the
 * OpenTelemetry resource data to enable analytics in terms of which platforms
 * use which dependencies.
 *
 * This behavior is opt-out using the `LUMIGO_REPORT_DEPENDENCIES=false`
 * environment variable. Additionally, data is sent only when the Lumigo endpoint
 * is the default one (as to avoid issues when tracing data is sent through proxies
 * like OpenTelemetry collectors), and it active only when a `LUMIGO_TRACER_TOKEN`
 * is present in the process environment.
 */
const promises_1 = require("fs/promises");
const utils_1 = require("../utils");
function report(dependenciesEndpoint, lumigoToken, resourceAttributes) {
    return __awaiter(this, void 0, void 0, function* () {
        const packages = yield listPackages();
        return ((0, utils_1.postUri)(dependenciesEndpoint, { resourceAttributes, packages }, { Authorization: `LumigoToken ${lumigoToken.trim()}` })
            /* eslint-disable */
            .catch(() => { })
        /* eslint-enable */
        );
    });
}
exports.report = report;
function listPackages() {
    return __awaiter(this, void 0, void 0, function* () {
        const validModulePaths = [];
        for (const modulesPath of module.paths) {
            try {
                // Basic existence check of the modulesPath (no actual FS access)
                yield (0, promises_1.access)(modulesPath);
                // Check if modulesPath is an actual directory
                const stats = yield (0, promises_1.lstat)(modulesPath);
                if (stats.isDirectory()) {
                    validModulePaths.push(modulesPath);
                }
            }
            catch (err) {
                /*
                 * Likely it is a default option, like /node_modules,
                 * that does not actually exist.
                 */
                continue;
            }
        }
        const packages = [];
        for (const modulesPath of validModulePaths) {
            const packageDirs = yield (0, promises_1.readdir)(modulesPath);
            for (const packageDir of packageDirs) {
                try {
                    const packageJsonFile = `${modulesPath}/${packageDir}/package.json`;
                    const content = yield (0, promises_1.readFile)(packageJsonFile);
                    const packageJson = JSON.parse(content.toString());
                    packages.push({
                        name: packageJson.name,
                        version: packageJson.version,
                    });
                }
                catch (err) {
                    /*
                     * Could be that the packageDir is actually not a directory,
                     * or that it does not contain a package.json file (so it is
                     * actually not a package directory), or that the package.json
                     * file is malformed. In any of these cases, it is not an actual
                     * dependency the application can load, so it is safe to skip.
                     */
                    continue;
                }
            }
        }
        return packages;
    });
}
//# sourceMappingURL=report.js.map
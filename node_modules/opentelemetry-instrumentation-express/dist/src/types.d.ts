import { Span } from '@opentelemetry/api';
import type express from 'express';
import { InstrumentationConfig } from '@opentelemetry/instrumentation';
export declare const PATH_STORE: unique symbol;
export declare const REQ_SPAN: unique symbol;
export declare const EXCEPTION_RECORDED: unique symbol;
export declare const CONSUMED_ROUTE_STATE: unique symbol;
export declare const ExpressInstrumentationAttributes: {
    /** This attribute will always contain the entire path. The part of the path that has been consumed by express will be shown as is (parameterized), and the leftover will be concatenated after (due to early termination or middleware that accept any path). */
    EXPRESS_ROUTE_FULL: string;
    /** This attribute is relevant when user configures multi path options for the same middleware. It reduces even further the cardinality space compared to `http.route`, and supply more info about how the app routing works. */
    EXPRESS_ROUTE_CONFIGURED: string;
    /** This attribute holds a json stringified map, where the keys are the url path param names, and the values are the matched params from the actual url. */
    EXPRESS_ROUTE_PARAMS: string;
    /** In case of internal error in instrumentation, this attribute will contain the error description. There are no known valid use cases which are expected to produce this attribute. */
    EXPRESS_INSTRUMENTATION_ERRORS: string;
    /** Set to true when request was not handled by any middleware in express, and got fallback to the default app `finalhandler`. This can happen if user sent request with invalid path or method (resulting in 404). */
    EXPRESS_UNHANDLED: string;
};
export declare type LayerPathAlternative = {
    userSuppliedValue: string | RegExp;
    displayValue: string;
    regexp: RegExp;
};
export declare type LayerPath = {
    fastSlash: boolean;
    alternatives: LayerPathAlternative | LayerPathAlternative[];
    displayValue: string;
};
export interface ExpressConsumedRouteState {
    resolvedRoute?: string;
    remainingRoute?: string;
    configuredRoute?: string;
    params?: Record<string, string>;
    isUnhandled?: boolean;
    errors?: string[];
}
export declare type Parameters<T> = T extends (...args: infer T) => any ? T : unknown[];
export declare type PatchedRequest = {
    [REQ_SPAN]?: Span;
    [CONSUMED_ROUTE_STATE]?: ExpressConsumedRouteState;
    __ot_middlewares?: string[];
} & express.Request;
export declare type PathParams = string | RegExp | Array<string | RegExp>;
export declare type ExpressRouter = {
    params: {
        [key: string]: string;
    };
    _params: string[];
    caseSensitive: boolean;
    mergeParams: boolean;
    strict: boolean;
    stack: ExpressLayer[];
};
export declare type ExpressLayer = {
    prototype: {
        handle_error: express.ErrorRequestHandler;
        handle_request: express.RequestHandler;
    };
    handle: Function;
    [PATH_STORE]?: LayerPath;
    name: string;
    params: {
        [key: string]: string;
    };
    path: string;
    regexp: RegExp;
};
export interface ExpressRequestHookInformation {
    moduleVersion?: string;
    req: express.Request;
    res: express.Response;
}
export declare type RequestHook = (span: Span, requestInfo: ExpressRequestHookInformation) => void;
export interface ExpressInstrumentationConfig extends InstrumentationConfig {
    /** Hook for adding custom attributes before express start handling the request */
    requestHook?: RequestHook;
    /** If set to true, plugin will include semantic http attributes in each express span */
    includeHttpAttributes?: boolean;
}
//# sourceMappingURL=types.d.ts.map
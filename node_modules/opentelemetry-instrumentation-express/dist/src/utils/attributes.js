"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseResponseStatus = exports.getHttpSpanAttributesFromReq = exports.createHostAttribute = exports.getSpanInitialName = exports.getSpanNameOnResEnd = exports.getHttpSpanAttributeFromRes = exports.getResolvedRoute = exports.getFullRoute = exports.getRouteAttributes = void 0;
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const types_1 = require("../types");
const getRouteAttributes = (routeState) => {
    const attributes = {};
    const resolvedRoute = exports.getResolvedRoute(routeState);
    if (resolvedRoute != null) {
        attributes[semantic_conventions_1.SemanticAttributes.HTTP_ROUTE] = resolvedRoute;
    }
    const fullRoute = exports.getFullRoute(routeState);
    if (fullRoute) {
        attributes[types_1.ExpressInstrumentationAttributes.EXPRESS_ROUTE_FULL] = fullRoute;
    }
    const configuredRoute = getConfiguredRoute(routeState);
    if (configuredRoute != null) {
        attributes[types_1.ExpressInstrumentationAttributes.EXPRESS_ROUTE_CONFIGURED] = configuredRoute;
    }
    if (typeof (routeState === null || routeState === void 0 ? void 0 : routeState.params) === 'object') {
        attributes[types_1.ExpressInstrumentationAttributes.EXPRESS_ROUTE_PARAMS] = JSON.stringify(routeState.params);
    }
    if (routeState === null || routeState === void 0 ? void 0 : routeState.isUnhandled) {
        attributes[types_1.ExpressInstrumentationAttributes.EXPRESS_UNHANDLED] = true;
    }
    if (routeState === null || routeState === void 0 ? void 0 : routeState.errors) {
        attributes[types_1.ExpressInstrumentationAttributes.EXPRESS_INSTRUMENTATION_ERRORS] = JSON.stringify(routeState.errors);
    }
    return attributes;
};
exports.getRouteAttributes = getRouteAttributes;
// might contain data with high cardinality, such as ids etc.
// this might happen on early termination due to authorization middlewares etc.
const getFullRoute = (expressRoutState) => {
    // exit when missing
    if (!expressRoutState)
        return;
    // exit when missing
    if (expressRoutState.resolvedRoute == null || expressRoutState.remainingRoute == null)
        return;
    return expressRoutState.resolvedRoute + expressRoutState.remainingRoute;
};
exports.getFullRoute = getFullRoute;
const getConfiguredRoute = (expressRoutState) => expressRoutState === null || expressRoutState === void 0 ? void 0 : expressRoutState.configuredRoute;
const getResolvedRoute = (expressRoutContext) => expressRoutContext === null || expressRoutContext === void 0 ? void 0 : expressRoutContext.resolvedRoute;
exports.getResolvedRoute = getResolvedRoute;
const getHttpSpanAttributeFromRes = (res) => {
    return {
        [semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE]: res.statusCode,
    };
};
exports.getHttpSpanAttributeFromRes = getHttpSpanAttributeFromRes;
const getSpanNameOnResEnd = (req, routeState) => {
    var _a;
    // route.path will give use
    const method = (_a = req === null || req === void 0 ? void 0 : req.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();
    const route = exports.getResolvedRoute(routeState);
    if (!method || !route)
        return undefined;
    return `${method} ${route}`;
};
exports.getSpanNameOnResEnd = getSpanNameOnResEnd;
const getSpanInitialName = (req) => {
    var _a, _b, _c;
    return `${(_b = (_a = req === null || req === void 0 ? void 0 : req.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : ''} ${(_c = req === null || req === void 0 ? void 0 : req.path) !== null && _c !== void 0 ? _c : ''}`;
};
exports.getSpanInitialName = getSpanInitialName;
const createHostAttribute = (req) => {
    var _a, _b;
    // prefer to use host from incoming headers
    const hostHeader = (_a = req.headers) === null || _a === void 0 ? void 0 : _a.host;
    if (hostHeader)
        return hostHeader;
    // if not available, construct it from parts
    const hostname = (_b = req.hostname) !== null && _b !== void 0 ? _b : 'localhost';
    return hostname;
};
exports.createHostAttribute = createHostAttribute;
const getHttpSpanAttributesFromReq = (req) => {
    return {
        [semantic_conventions_1.SemanticAttributes.HTTP_METHOD]: req.method.toUpperCase(),
        [semantic_conventions_1.SemanticAttributes.HTTP_TARGET]: req.originalUrl,
        [semantic_conventions_1.SemanticAttributes.HTTP_FLAVOR]: req.httpVersion,
        [semantic_conventions_1.SemanticAttributes.HTTP_HOST]: exports.createHostAttribute(req),
        [semantic_conventions_1.SemanticAttributes.HTTP_SCHEME]: req.protocol,
        [semantic_conventions_1.SemanticAttributes.NET_PEER_IP]: req.ip,
    };
};
exports.getHttpSpanAttributesFromReq = getHttpSpanAttributesFromReq;
// from @opentelemetry/instrumentation-http
// https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-instrumentation-http/src/utils.ts#L70
const parseResponseStatus = (statusCode) => {
    // 1xx, 2xx, 3xx are OK
    if (statusCode >= 100 && statusCode < 400) {
        return { code: api_1.SpanStatusCode.OK };
    }
    // All other codes are error
    return { code: api_1.SpanStatusCode.ERROR };
};
exports.parseResponseStatus = parseResponseStatus;
//# sourceMappingURL=attributes.js.map
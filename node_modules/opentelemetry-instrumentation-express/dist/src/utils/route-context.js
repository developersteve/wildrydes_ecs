"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInitialRouteState = exports.consumeLayerPathAndUpdateState = exports.getUsedPathFromLayerPath = void 0;
const parseurl_1 = __importDefault(require("parseurl"));
const getUsedPathFromLayerPath = (layerPath, actualUrl) => {
    var _a;
    if (Array.isArray(layerPath === null || layerPath === void 0 ? void 0 : layerPath.alternatives)) {
        const matchedAlternative = layerPath.alternatives.find((alternative) => alternative.regexp.exec(actualUrl));
        if (!matchedAlternative) {
            return { error: 'could not match url path to any of the registered path alternatives' };
        }
        const resolvedPath = matchedAlternative.displayValue;
        if (resolvedPath === undefined) {
            return { error: 'error while resolving path for matched alternative on paths array in express' };
        }
        return { resolvedPath };
        // return layerPath.alternatives.map((alternative) => alternative.displayValue).toString();
    }
    else {
        const resolvedPath = (_a = layerPath === null || layerPath === void 0 ? void 0 : layerPath.alternatives) === null || _a === void 0 ? void 0 : _a.displayValue;
        if (resolvedPath === undefined) {
            return { error: 'error while resolving path in express' };
        }
        return { resolvedPath };
    }
};
exports.getUsedPathFromLayerPath = getUsedPathFromLayerPath;
const consumeLayerPathAndUpdateState = (currentParts, req, currentLayerPath) => {
    var _a;
    const currentReqPath = req.path;
    const { resolvedPath, error: resolvedPathError } = exports.getUsedPathFromLayerPath(currentLayerPath, currentParts.remainingRoute);
    if (resolvedPathError) {
        return {
            errors: [...((_a = currentParts.errors) !== null && _a !== void 0 ? _a : []), resolvedPathError],
        };
    }
    const layerConfiguredPath = currentLayerPath === null || currentLayerPath === void 0 ? void 0 : currentLayerPath.displayValue;
    const remainingRoute = req.route ? '' : currentReqPath === '/' ? '' : currentReqPath;
    const resolvedRoute = !currentLayerPath.fastSlash
        ? currentParts.resolvedRoute + resolvedPath
        : currentParts.resolvedRoute;
    const configuredRoute = !currentLayerPath.fastSlash
        ? currentParts.configuredRoute + layerConfiguredPath
        : currentParts.configuredRoute;
    const params = Object.assign(Object.assign({}, currentParts.params), req.params);
    return {
        resolvedRoute,
        remainingRoute,
        configuredRoute,
        params,
    };
};
exports.consumeLayerPathAndUpdateState = consumeLayerPathAndUpdateState;
const createInitialRouteState = (req) => {
    // at this point, we have the raw http req object, and not the express req.
    // thus, we cannot call req.path
    // we use parseurl(req).pathname which is exactly what express is doing
    const path = parseurl_1.default(req).pathname;
    return { resolvedRoute: '', remainingRoute: path, configuredRoute: '', params: {} };
};
exports.createInitialRouteState = createInitialRouteState;
//# sourceMappingURL=route-context.js.map
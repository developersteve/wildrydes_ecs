"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressInstrumentation = void 0;
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const types_1 = require("./types");
const version_1 = require("./version");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const attributes_1 = require("./utils/attributes");
const route_context_1 = require("./utils/route-context");
const layer_path_1 = require("./utils/layer-path");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const originalLayerStore = Symbol('otel.express-plugins.orig-layer-export');
class ExpressInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
        super('opentelemetry-instrumentation-express', version_1.VERSION, Object.assign({}, config));
    }
    setConfig(config = {}) {
        this._config = Object.assign({}, config);
    }
    init() {
        const layerModule = new instrumentation_1.InstrumentationNodeModuleFile('express/lib/router/layer.js', ExpressInstrumentation.supportedVersions, this._patchExpressLayer.bind(this), this._unpatchExpressLayer.bind(this));
        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('express', ExpressInstrumentation.supportedVersions, this.patch.bind(this), this.unpatch.bind(this), [layerModule]);
        return module;
    }
    patch(moduleExports, moduleVersion) {
        if (moduleExports === undefined || moduleExports === null) {
            return moduleExports;
        }
        api_1.diag.debug('opentelemetry.express instrumentation: patching express application lazyrouter');
        // convert to any so we don't get errors because lazyrouter is not public
        const application = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.application;
        if (instrumentation_1.isWrapped(application === null || application === void 0 ? void 0 : application.lazyrouter)) {
            this._unwrap(application, 'lazyrouter');
        }
        this._wrap(application, 'lazyrouter', this.getApplicationLazyRouterPatch.bind(this, moduleVersion));
        return moduleExports;
    }
    unpatch(moduleExports) {
        api_1.diag.debug('opentelemetry.express instrumentation: unpatching Express application lazyrouter');
        this._unwrap(moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.application, 'lazyrouter');
    }
    _patchExpressLayer(moduleExports, version) {
        const self = this;
        if (moduleExports === undefined || moduleExports === null) {
            return moduleExports;
        }
        const origLayerConstructor = moduleExports;
        const LayerPrototype = moduleExports.prototype;
        api_1.diag.debug('opentelemetry.express instrumentation: patching Express Layer handle_request and handle_error');
        this._wrap(LayerPrototype, 'handle_request', this._getLayerHandleRequestPatch.bind(this));
        this._wrap(LayerPrototype, 'handle_error', this._getLayerHandleErrorPatch.bind(this));
        // patch the Layer constructor to collect the 'path'
        function OtelPatchedLayer(path, options, fn) {
            if (!(this instanceof OtelPatchedLayer)) {
                return new OtelPatchedLayer(path, options, fn);
            }
            this[types_1.PATH_STORE] = layer_path_1.getLayerPathFromFirstArg(path, options !== null && options !== void 0 ? options : {});
            return origLayerConstructor.call(this, path, options, fn);
        }
        OtelPatchedLayer.prototype = LayerPrototype;
        OtelPatchedLayer[originalLayerStore] = moduleExports;
        return OtelPatchedLayer;
    }
    _unpatchExpressLayer(moduleExports) {
        var _a;
        api_1.diag.debug('opentelemetry.express instrumentation: unpatching Express Layer');
        const originalLayerExport = (_a = moduleExports[originalLayerStore]) !== null && _a !== void 0 ? _a : moduleExports;
        if (instrumentation_1.isWrapped(originalLayerExport.prototype.handle_request)) {
            this._unwrap(originalLayerExport.prototype, 'handle_request');
        }
        if (instrumentation_1.isWrapped(originalLayerExport.prototype.handle_error)) {
            this._unwrap(originalLayerExport.prototype, 'handle_error');
        }
        return originalLayerExport;
    }
    _getLayerHandleRequestPatch(original) {
        const self = this;
        return function (req, res, next) {
            // this is what express is doing to check if layer should be invoke
            if (this.handle.length > 3) {
                return original.apply(this, arguments);
            }
            const { origState, newState } = self.getRoutingStateOnConsumingPath(req, this);
            const pluginNext = function errorHandlingNext(err) {
                if (err && err !== 'route' && err !== 'router') {
                    self._recordException(req, err);
                }
                self.runMiddlewareWithContext(origState, req, () => next(err));
            };
            return self.runMiddlewareWithContext(newState, req, () => original.call(this, req, res, pluginNext));
        };
    }
    _getLayerHandleErrorPatch(original) {
        const self = this;
        return function (err, req, res, next) {
            // this is what express is doing to check if layer should be invoke
            if (this.handle.length !== 4) {
                return original.apply(this, arguments);
            }
            const { origState, newState } = self.getRoutingStateOnConsumingPath(req, this);
            const pluginNext = function errorHandlingNext(err) {
                if (err !== 'route' && err !== 'router') {
                    self._recordException(req, err);
                }
                self.runMiddlewareWithContext(origState, req, () => next(err));
            };
            return self.runMiddlewareWithContext(newState, req, () => original.call(this, err, req, res, pluginNext));
        };
    }
    _recordException(req, err) {
        try {
            if (!err || err[types_1.EXCEPTION_RECORDED]) {
                return;
            }
            const span = req[types_1.REQ_SPAN];
            if (!span) {
                return;
            }
            span.recordException(err);
            // mark as recorded to avoid duplicates
            Object.defineProperty(err, types_1.EXCEPTION_RECORDED, {
                enumerable: false,
                value: true,
            });
        }
        catch (_a) { }
    }
    registerInstrumentationMiddleware(app, moduleVersion) {
        const plugin = this;
        app.use((req, res, next) => {
            // check if this app was mounted in another express app.
            // we want the logic to run just once per request
            if (req.hasOwnProperty(types_1.REQ_SPAN)) {
                next();
                return;
            }
            const spanName = attributes_1.getSpanInitialName(req);
            const span = plugin.tracer.startSpan(spanName, {
                kind: api_1.SpanKind.INTERNAL,
                attributes: plugin._config.includeHttpAttributes ? attributes_1.getHttpSpanAttributesFromReq(req) : {},
            });
            if (plugin._config.requestHook) {
                instrumentation_1.safeExecuteInTheMiddle(() => plugin._config.requestHook(span, { moduleVersion, req, res }), (e) => {
                    if (e)
                        api_1.diag.error(`opentelemetry.express instrumentation: requestHook error`, e);
                }, true);
            }
            Object.defineProperty(req, types_1.REQ_SPAN, {
                enumerable: false,
                value: span,
            });
            const oldResEnd = res.end;
            res.end = function () {
                const routeState = plugin.getCurrentRouteState(req);
                const routeAttributes = attributes_1.getRouteAttributes(routeState);
                const route = routeAttributes[semantic_conventions_1.SemanticAttributes.HTTP_ROUTE];
                if (route) {
                    const rpcMetadata = core_1.getRPCMetadata(api_1.context.active());
                    if (rpcMetadata) {
                        rpcMetadata.route = route;
                    }
                }
                const origRes = oldResEnd.apply(res, arguments);
                span.setAttributes(routeAttributes);
                if (plugin._config.includeHttpAttributes) {
                    span.setAttributes(attributes_1.getHttpSpanAttributeFromRes(res));
                }
                span.setStatus(attributes_1.parseResponseStatus(res.statusCode));
                const newSpanName = attributes_1.getSpanNameOnResEnd(req, routeState);
                if (newSpanName) {
                    span.updateName(newSpanName);
                }
                span.end();
                return origRes;
            };
            next();
        });
    }
    getApplicationLazyRouterPatch(moduleVersion, original) {
        const self = this;
        return function patchedLazyRouter() {
            const origRes = original.apply(this, arguments);
            if (!instrumentation_1.isWrapped(this._router.handle)) {
                self._wrap(this._router, 'handle', self.getAppRouterHandlerPatch.bind(self));
                self.registerInstrumentationMiddleware(this, moduleVersion);
            }
            return origRes;
        };
    }
    getAppRouterHandlerPatch(original) {
        const self = this;
        return function patchedAppRouterHandle(req, res, next) {
            // check that this is indeed the entry point to the app
            // we will hit this if on mounted app cases
            const currentState = self.getCurrentRouteState(req);
            if (currentState) {
                return original.apply(this, arguments);
            }
            const initialState = route_context_1.createInitialRouteState(req);
            const patchedNext = function (err) {
                return self.runMiddlewareWithContext(Object.assign(Object.assign({}, initialState), { isUnhandled: true }), req, () => next(err));
            };
            return self.runMiddlewareWithContext(initialState, req, () => original.call(this, req, res, patchedNext));
        };
    }
    getRoutingStateOnConsumingPath(req, layer) {
        const origContext = api_1.context.active();
        const currentState = this.getCurrentRouteState(req);
        // we must have an express context at this point (which was create at app router)
        // if we don't, than this is an error
        if (!currentState) {
            const errorState = {
                errors: ['internal error in express instrumentation: missing route context'],
            };
            return { origState: errorState, newState: errorState };
        }
        const currentLayerPath = layer[types_1.PATH_STORE];
        const newExpressRouteState = route_context_1.consumeLayerPathAndUpdateState(currentState, req, currentLayerPath);
        return { origState: currentState, newState: newExpressRouteState };
    }
    // we would like to rely on otel context which propagate correctly via async calls.
    // the issue is that sometimes this mechanism fails due to timers / event emitters / thenables etc.
    // then we get just an empty context which we cannot extract route from.
    // so we install a fallback which should cover most cases - save the route state on the request as well,
    // and restore it when the middleware is done
    runMiddlewareWithContext(consumeRouteState, req, fn) {
        Object.defineProperty(req, types_1.CONSUMED_ROUTE_STATE, {
            value: consumeRouteState,
            enumerable: false,
            configurable: true,
        });
        const middlewareResult = api_1.context.with(api_1.context.active().setValue(types_1.CONSUMED_ROUTE_STATE, consumeRouteState), fn);
        return middlewareResult;
    }
    getCurrentRouteState(req) {
        var _a;
        return ((_a = api_1.context.active().getValue(types_1.CONSUMED_ROUTE_STATE)) !== null && _a !== void 0 ? _a : req[types_1.CONSUMED_ROUTE_STATE]);
    }
}
exports.ExpressInstrumentation = ExpressInstrumentation;
ExpressInstrumentation.supportedVersions = ['^4.9.0'];
//# sourceMappingURL=express.js.map